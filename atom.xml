<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>我喜欢你喜欢我的歌</title>
  
  <subtitle>Dick</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://wxzhongwang.github.io/"/>
  <updated>2019-08-23T15:46:17.980Z</updated>
  <id>https://wxzhongwang.github.io/</id>
  
  <author>
    <name>Dick Zhong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="https://wxzhongwang.github.io/2019/08/22/ConcurrentHashMap%20%E5%92%8C%20Hashtable%20%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://wxzhongwang.github.io/2019/08/22/ConcurrentHashMap 和 Hashtable 的区别/</id>
    <published>2019-08-22T13:58:18.239Z</published>
    <updated>2019-08-23T15:46:17.980Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ConcurrentHashMap-和-Hashtable-的区别"><a href="#ConcurrentHashMap-和-Hashtable-的区别" class="headerlink" title="ConcurrentHashMap 和 Hashtable 的区别"></a>ConcurrentHashMap 和 Hashtable 的区别</h1><h2 id="底层数据结构"><a href="#底层数据结构" class="headerlink" title="底层数据结构"></a>底层数据结构</h2><h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><p>[JDK1.7]<br>ConcurrentHashMap 底层采用 分段的数组+链表 实现，<br>[JDK1.8]<br>ConcurrentHashMap 采用的数据结构跟HashMap1.8的结构一样，数组+链表/红黑二叉树。</p><h3 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h3><p>Hashtable 和 JDK1.8 之前的 HashMap 的底层数据结构类似都是采用 数组+链表 的形式，<br>数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；</p><h2 id="实现线程安全的方式（重要）"><a href="#实现线程安全的方式（重要）" class="headerlink" title="实现线程安全的方式（重要）"></a>实现线程安全的方式（重要）</h2><h3 id="ConcurrentHashMap-1"><a href="#ConcurrentHashMap-1" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><p>[JDK1.7]<br>ConcurrentHashMap（分段锁） 对整个桶数组进行了分割分段(Segment)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，<br>就不会存在锁竞争，提高并发访问率。<br>[JDK1.8]<br>摒弃了Segment的概念，而是直接用 Node 数组 + 链表 + 红黑树 的数据结构来实现，并发控制使用 synchronized 和 CAS 来操作。<br>（JDK1.6以后 对 synchronized锁做了很多优化） 整个看起来就像是优化过且线程安全的 HashMap，<br>虽然在JDK1.8中还能看到 Segment 的数据结构，但是已经简化了属性，只是为了兼容旧版本；</p><h3 id="Hashtable-同一把锁"><a href="#Hashtable-同一把锁" class="headerlink" title="Hashtable(同一把锁)"></a>Hashtable(同一把锁)</h3><p>使用 synchronized 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，<br>可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，<br>竞争会越来越激烈效率越低。HashTable性能差主要是由于所有操作需要竞争同一把锁，而如果容器中有多把锁，<br>每一把锁锁一段数据，这样在多线程访问时不同段的数据时，就不会存在锁竞争了，这样便可以有效地提高并发效率。<br>这就是ConcurrentHashMap所采用的”分段锁”思想。</p><p><strong>HashTable:</strong></p><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/HashTable全表锁.png" alt="HashTable全表锁"></p><p><strong>JDK1.7的ConcurrentHashMap：</strong></p><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/ConcurrentHashMap分段锁.jpg" alt="JDK1.7的ConcurrentHashMap"></p><p><strong>JDK1.8的ConcurrentHashMap（TreeBin: 红黑二叉树节点 Node: 链表节点）：</strong></p><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/JDK1.8-ConcurrentHashMap-Structure.jpg" alt="JDK1.8的ConcurrentHashMap"></p><p>　　</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ConcurrentHashMap-和-Hashtable-的区别&quot;&gt;&lt;a href=&quot;#ConcurrentHashMap-和-Hashtable-的区别&quot; class=&quot;headerlink&quot; title=&quot;ConcurrentHashMap 和 Hashta
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>NOSQL</title>
    <link href="https://wxzhongwang.github.io/2019/08/07/NOSQL/"/>
    <id>https://wxzhongwang.github.io/2019/08/07/NOSQL/</id>
    <published>2019-08-07T14:59:05.594Z</published>
    <updated>2019-08-11T05:15:06.198Z</updated>
    
    <content type="html"><![CDATA[<h1 id="NOSQL"><a href="#NOSQL" class="headerlink" title="NOSQL"></a>NOSQL</h1><p>全称：NoSQL = Not Only SQL</p><p>泛指非关系型数据库</p><p>四大分类：</p><p>1）键值(Key-Value)存储数据库</p><p>Key/value模型对于IT系统来说的优势在于简单、易部署。<br>但是如果DBA只对部分值进行查询或更新的时候，Key/value就显得效率低下了。<br>举例如：Redis.</p><p>2）列存储数据库</p><p>这部分数据库通常是用来应对分布式存储的海量数据。<br>键仍然存在，但是它们的特点是指向了多个列。这些列是由列家族来安排的。<br>如：Cassandra, HBase, Riak.</p><p>3）文档型</p><p>文档型数据库的灵感是来自于Lotus Notes办公软件的，而且它同第一种键值存储相类似。<br>该类型的数据模型是版本化的文档，半结构化的文档以特定的格式存储，比如JSON。<br>文档型数据库可以看作是键值数据库的升级版，允许之间嵌套键值。<br>而且文档型数据库比键值数据库的查询效率更高。如：CouchDB, MongoDb.<br>国内也有文档型数据库SequoiaDB，已经开源。</p><p>4）图形(Graph)数据库</p><p>图形结构的数据库同其他行列以及刚性结构的SQL数据库不同，它是使用灵活的图形模型，并且能够扩展到多个服务器上。</p><p>NoSQL数据库没有标准的查询语言(SQL)，因此进行数据库查询需要制定数据模型。<br>许多NoSQL数据库都有REST式的数据接口或者查询API。</p><p>我们总结NoSQL数据库在以下的这几种情况下比较适用：</p><ol><li>数据模型比较简单；</li><li>需要灵活性更强的IT系统；</li><li>对数据库性能要求较高；</li><li>不需要高度的数据一致性；</li><li>对于给定key，比较容易映射复杂值的环境。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;NOSQL&quot;&gt;&lt;a href=&quot;#NOSQL&quot; class=&quot;headerlink&quot; title=&quot;NOSQL&quot;&gt;&lt;/a&gt;NOSQL&lt;/h1&gt;&lt;p&gt;全称：NoSQL = Not Only SQL&lt;/p&gt;
&lt;p&gt;泛指非关系型数据库&lt;/p&gt;
&lt;p&gt;四大分类：&lt;/p&gt;

      
    
    </summary>
    
      <category term="Redis" scheme="https://wxzhongwang.github.io/categories/Redis/"/>
    
    
      <category term="Redis" scheme="https://wxzhongwang.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>互联网金融行业数仓分层</title>
    <link href="https://wxzhongwang.github.io/2019/08/07/%E4%BA%92%E8%81%94%E7%BD%91%E9%87%91%E8%9E%8D%E8%A1%8C%E4%B8%9A%E6%95%B0%E4%BB%93%E5%88%86%E5%B1%82/"/>
    <id>https://wxzhongwang.github.io/2019/08/07/互联网金融行业数仓分层/</id>
    <published>2019-08-07T14:37:26.011Z</published>
    <updated>2019-06-27T11:05:10.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="互联网金融行业数仓分层"><a href="#互联网金融行业数仓分层" class="headerlink" title="互联网金融行业数仓分层"></a>互联网金融行业数仓分层</h1><h2 id="专业术语"><a href="#专业术语" class="headerlink" title="专业术语"></a>专业术语</h2><ul><li><p>ODL层 （Operational Data Layer）：操作数据层</p><blockquote><p>外部数据什么样，该层数据就是什么样（关系型数据库、JSON格式等)<br>部分关系型数据可以直接转IDL层</p></blockquote></li><li><p>BDL层 （Base Data Layer）：基础数据层</p><blockquote><p>ODL层经过简单格式化解析后存储到BDL层，常见于JSON日志格式的解析。</p></blockquote></li><li><p>IDL层 （Interface Data Layer）：接口层，也称主题表，宽表</p><blockquote><p>由BDL层经过去重、去噪、字典翻译、空值转化，日期格式化、关联JOIN、维度分析等清洗后的数据。如：用户、产品、绑卡、订单、用户行为等明细数据。</p></blockquote></li><li><p>ADL层（Application Data Layer）：应用层 ，也称数据集市</p><blockquote><p>通常与需求对接，由IDL层基于某些维度的深度加工统计汇总等操作转化而来，涉及到多个主题以及tmp数据之间的关联JOIN后的结果。</p></blockquote></li><li><p>DIC层（Dictionary Data Layer）：字典层</p><blockquote><p>存储一些诸如省、市、县区域表、渠道列表、商品类目等等表数据，可以从数据源直接sqoop生成dic_xxx表，也可以通过odl层转化层dic_表。</p></blockquote></li><li><p>TMP层（Temporary Data Layer）：临时层</p><blockquote><p>存储一些中间计算结果</p></blockquote></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/3763924-bfd47ed0607208d2.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp" alt="image"></p><p>简要说明:</p><blockquote><ol><li>层次间的转换没必要循规蹈矩，按部就班，适当做到灵活，避免重复清洗浪费资源</li><li>ODL层干净的关系型数据可以直接转换为IDL层数据，减少计算量</li><li>ODL层侧重与外部对接，BDL层/TMP层/IDL层侧重清洗，IDL层和ADL层侧重对外提供应用服务</li><li>层数太少不够灵活，太多则在数据推翻重洗耗时，时间成本（一个坑）<br>数据源提供的数据越详细越好，避免后期大量重复的清洗工作。</li></ol></blockquote><h2 id="“星型模型”和“雪花模型”"><a href="#“星型模型”和“雪花模型”" class="headerlink" title="“星型模型”和“雪花模型”"></a>“星型模型”和“雪花模型”</h2><p>简单解释：  </p><ul><li>（1）星型模型：事实表+维度表（区域、类目、性别…)等多表通过预先JOIN冗余到一张宽表里去，常见IDL层。</li><li>（2）雪花模型：在计算的时候，才将事实表跟维度表做join。</li></ul><blockquote><p>现在一般都是采用（1）的模式，为什么呢？   预先计算，挺高性能，避免后续重复计算。CPU和内存的资源永远比磁盘空间宝贵的多。<br>至于（2)的方式，有点就是灵活，不需要太多的重复清洗，但是性能不如（1）.</p></blockquote><h2 id="建设思路"><a href="#建设思路" class="headerlink" title="建设思路"></a>建设思路</h2><blockquote><p>从需求出发，逆推应用层ADL结构，进而推导出它涉及的主题表IDL表结构，再推导可能涉及的基础表BDL表结构，最后分析所需的数据源取自何处。<br>需求包含“明确”需求和“潜在”需求。</p></blockquote><h2 id="开发步骤"><a href="#开发步骤" class="headerlink" title="开发步骤"></a>开发步骤</h2><ol><li>创建ODL、BDL、IDL、ADL层表结构(HQL)</li><li>确定数据抽取方案（增量或全量）</li><li>编写sqoop脚本将data同步到ODL层</li><li>编写ODL-&gt;BDL-&gt;IDL-&gt;ADL层ETL清洗脚本(HQL),注意：清洗的顺序，时间<br>确保上一层的数据稳定，减少对下一层的影响</li><li>编写Hue workflow Ooize脚本</li><li>打通Kylin、FineBI、Hive关系，实现数据可视化、可导出目标,将稳定后所有脚本WIKI上保存一份</li></ol><p>其他相关的请参照原博客</p><p>作者：水星有鱼<br>链接：<a href="https://www.jianshu.com/p/f941967aeee8" target="_blank" rel="noopener">https://www.jianshu.com/p/f941967aeee8</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;互联网金融行业数仓分层&quot;&gt;&lt;a href=&quot;#互联网金融行业数仓分层&quot; class=&quot;headerlink&quot; title=&quot;互联网金融行业数仓分层&quot;&gt;&lt;/a&gt;互联网金融行业数仓分层&lt;/h1&gt;&lt;h2 id=&quot;专业术语&quot;&gt;&lt;a href=&quot;#专业术语&quot; class=&quot;
      
    
    </summary>
    
      <category term="数据仓库" scheme="https://wxzhongwang.github.io/categories/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93/"/>
    
    
      <category term="数据仓库" scheme="https://wxzhongwang.github.io/tags/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>SparkStreaming和Storm</title>
    <link href="https://wxzhongwang.github.io/2019/08/07/SparkStreaming%E5%92%8CStorm%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://wxzhongwang.github.io/2019/08/07/SparkStreaming和Storm的区别/</id>
    <published>2019-08-07T14:37:26.004Z</published>
    <updated>2019-06-27T11:05:08.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SparkStreaming和Storm"><a href="#SparkStreaming和Storm" class="headerlink" title="SparkStreaming和Storm"></a>SparkStreaming和Storm</h1><p>Storm和Spark Streaming都是分布式流处理的开源框架，但是它们之间还是有一些区别的，这里将进行比较并指出它们的重要的区别。</p><h2 id="处理模型以及延迟"><a href="#处理模型以及延迟" class="headerlink" title="处理模型以及延迟"></a>处理模型以及延迟</h2><p>虽然这两个框架都提供可扩展性(Scalability)和可容错性(Fault Tolerance),但是它们的处理模型从根本上说是不一样的。Storm处理的是每次传入的一个事件，而Spark Streaming是处理某个时间段窗口内的事件流。因此，Storm处理一个事件可以达到亚秒级的延迟，而Spark Streaming则有秒级的延迟。</p><h2 id="容错和数据保证"><a href="#容错和数据保证" class="headerlink" title="容错和数据保证"></a>容错和数据保证</h2><p>在容错数据保证方面的权衡方面，Spark Streaming提供了更好的支持容错状态计算。在Storm中，当每条单独的记录通过系统时必须被跟踪，所以Storm能够至少保证每条记录将被处理一次，但是在从错误中恢复过来时候允许出现重复记录，这意味着可变状态可能不正确地被更新两次。而Spark Streaming只需要在批处理级别对记录进行跟踪处理，因此可以有效地保证每条记录将完全被处理一次，即便一个节点发生故障。虽然Storm的 Trident library库也提供了完全一次处理的功能。但是它依赖于事务更新状态，而这个过程是很慢的，并且通常必须由用户实现。</p><p>简而言之,如果你需要亚秒级的延迟，Storm是一个不错的选择，而且没有数据丢失。如果你需要有状态的计算，而且要完全保证每个事件只被处理一次，Spark Streaming则更好。Spark Streaming编程逻辑也可能更容易，因为它类似于批处理程序，特别是在你使用批次(尽管是很小的)时。</p><h2 id="实现和编程API"><a href="#实现和编程API" class="headerlink" title="实现和编程API"></a>实现和编程API</h2><p>Storm主要是由Clojure语言实现，SparkStreaming是由Scala实现。如果你想看看这两个框架是如何实现的或者你想自定义一些东西你就得记住这一点。Storm是由BackType和Twitter开发，而Spark Streaming是在UC Berkeley开发的。</p><p>Storm提供了Java API，同时也支持其他语言的API。SparkStreaming支持Scala和Java语言(其实也支持Python)。另外SparkStreaming的一个很棒的特性就是它是在Spark框架上运行的。这样你就可以想使用其他批处理代码一样来写SparkStreaming程序，或者是在Spark中交互查询。这就减少了单独编写流批量处理程序和历史数据处理程序。</p><h2 id="生产支持"><a href="#生产支持" class="headerlink" title="生产支持"></a>生产支持</h2><p>Storm已经出现好多年了，而且自从2011年开始就在Twitter内部生产环境中使用，还有其他一些公司。而Spark Streaming是一个新的项目，并且在2013年仅仅被Sharethrough使用(据作者了解)。</p><p>Storm是 Hortonworks Hadoop数据平台中流处理的解决方案，而Spark Streaming出现在 MapR的分布式平台和Cloudera的企业数据平台中。除此之外，Databricks是为Spark提供技术支持的公司，包括了Spark Streaming。</p><h2 id="集群管理集成"><a href="#集群管理集成" class="headerlink" title="集群管理集成"></a>集群管理集成</h2><p>尽管两个系统都运行在它们自己的集群上，Storm也能运行在Mesos，而SparkStreaming能运行在YARN 和 Mesos上。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;SparkStreaming和Storm&quot;&gt;&lt;a href=&quot;#SparkStreaming和Storm&quot; class=&quot;headerlink&quot; title=&quot;SparkStreaming和Storm&quot;&gt;&lt;/a&gt;SparkStreaming和Storm&lt;/h1&gt;&lt;
      
    
    </summary>
    
      <category term="大数据" scheme="https://wxzhongwang.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="Hadoop" scheme="https://wxzhongwang.github.io/tags/Hadoop/"/>
    
  </entry>
  
  <entry>
    <title>Java基础面试题四</title>
    <link href="https://wxzhongwang.github.io/2019/08/07/Java%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98%E5%9B%9B/"/>
    <id>https://wxzhongwang.github.io/2019/08/07/Java基础面试题四/</id>
    <published>2019-08-07T14:37:25.985Z</published>
    <updated>2019-08-11T05:16:14.083Z</updated>
    
    <content type="html"><![CDATA[<p>Java基础面试题四</p><blockquote><p>Q1: Java中垃圾回收有什么目的？什么时候进行垃圾回收？ </p></blockquote><p>垃圾回收的目的是识别并且丢弃应用不再使用的对象来释放和重用资源。</p><blockquote><p>Q2：如果对象的引用被置为null，垃圾收集器是否会立即释放对象占用的内存？ </p></blockquote><p>不会，在下一个垃圾回收周期中，这个对象将是可被回收的。</p><blockquote><p>Q3: String是最基本的数据类型吗? </p></blockquote><p>基本数据类型包括:</p><ul><li>byte</li><li>int</li><li>char</li><li>long</li><li>float</li><li>double</li><li>boolean</li><li>short </li></ul><p>java.lang.String类是final类型的，因此不可以继承这个类、不能修改这个类。为了提高效率节省空间，我们应该用StringBuffer类。</p><blockquote><p>Q4: int 和 Integer 有什么区别?</p></blockquote><p>Java 提供两种不同的类型：引用类型和原始类型（或内置类型）。Int是java的原始数据类型，Integer是java为int提供的封装类。Java为每个原始类型提供了封装类。</p><blockquote><p>Q5: String 和 StringBuffer的区别?</p></blockquote><p>JAVA平台提供了两个类：String和StringBuffer，它们可以储存和操作字符串，即包含多个字符的字符数据。这个String类提供了数值不可改变的字符串。而这个StringBuffer类提供的字符串进行修改。</p><blockquote><p>Q6: ArrayList,Vector,LinkedList的存储性能和特性?</p></blockquote><p>ArrayList和Vector都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢，Vector由于使用了synchronized方法（线程安全），通常性能上较ArrayList差，而LinkedList使用双向链表实现存储，按序号索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本项的前后项即可，所以插入速度较快。<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">List的子类特点</span><br><span class="line"><span class="symbol">        ArrayList:</span></span><br><span class="line">            底层数据结构是数组，查询快，增删慢</span><br><span class="line">            线程不安全，效率高</span><br><span class="line"><span class="symbol">        Vector:</span></span><br><span class="line">            底层数据结构是数组，查询快，增删慢</span><br><span class="line">            线程安全，效率低</span><br><span class="line"><span class="symbol">        LinkedList:</span></span><br><span class="line">            底层数据结构是链表，查询慢，增删快</span><br><span class="line">            线程不安全，效率高</span><br></pre></td></tr></table></figure></p><blockquote><p>Q7: Collection 和 Collections的区别 </p></blockquote><p>Collection是集合类的上级接口，继承与他的接口主要有Set和List. </p><p>Collections是针对集合类的一个帮助类，他提供一系列静态方法实现对各种集合的搜索、排序、线程安全化等操作。<br>集合的继承体系：<br><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1551609409314&amp;di=26c716fbc7abe264f61d07f051639caf&amp;imgtype=0&amp;src=http%3A%2F%2Faliyunzixunbucket.oss-cn-beijing.aliyuncs.com%2Fjpg%2F16f3e1d844693be57f7e0f55c969f42d.jpg%3Fx-oss-process%3Dimage%2Fresize%2Cp_100%2Fauto-orient%2C1%2Fquality%2Cq_90%2Fformat%2Cjpg%2Fwatermark%2Cimage_eXVuY2VzaGk%3D%2Ct_100" alt="image"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Java基础面试题四&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Q1: Java中垃圾回收有什么目的？什么时候进行垃圾回收？ &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;垃圾回收的目的是识别并且丢弃应用不再使用的对象来释放和重用资源。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;
      
    
    </summary>
    
      <category term="Java" scheme="https://wxzhongwang.github.io/categories/Java/"/>
    
    
      <category term="面试题" scheme="https://wxzhongwang.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Java基础面试题五</title>
    <link href="https://wxzhongwang.github.io/2019/08/07/Java%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98%E4%BA%94/"/>
    <id>https://wxzhongwang.github.io/2019/08/07/Java基础面试题五/</id>
    <published>2019-08-07T14:37:25.985Z</published>
    <updated>2019-08-11T05:16:10.202Z</updated>
    
    <content type="html"><![CDATA[<p>Java基础面试题五</p><blockquote><p>Q1: &amp; 和 &amp;&amp; 的区别</p></blockquote><p>&amp;是位运算符，表示按位与运算，&amp;&amp;是逻辑运算符，表示逻辑与（and）。</p><blockquote><p>Q2: final, finally, finalize的区别</p></blockquote><ul><li>final 用于声明属性，方法和类，分别表示属性不可变，方法不可覆盖，类不可继承。 </li><li>finally,异常处理语句结构的一部分，表示总是执行。 </li><li>finalize是Object类的一个方法，垃圾收集器执行的时候会调用被回收对象的此方法，可以覆盖此方法提供垃圾收集时的其他资源回收，例如关闭文件等。</li></ul><blockquote><p>Q3: sleep() 和 wait() 有什么区别? </p></blockquote><p>sleep是线程类（Thread）的方法，导致此线程暂停执行指定时间，给执行机会给其他线程，但是监控状态依然保持，到时后会自动恢复。调用sleep不会释放对象锁。 </p><p>wait是Object类的方法，对此对象调用wait方法导致本线程放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象发出notify方法（或not ifyAll）后本线程才进入对象锁定池准备获得对象锁进入运行状态。</p><blockquote><p>Q4: error和exception有什么区别? </p></blockquote><ul><li>error:<br>表示恢复不是不可能但很困难的情况下的一种严重问题。比如说内存溢出。不可能指望程序能处理这样的情况。 </li><li>exception: 表示一种设计或实现问题。也就是说，它表示如果程序运行正常，从不会发生的情况。</li></ul><blockquote><p>Q5: GC是什么? 为什么要有GC? </p></blockquote><p>GC是垃圾收集的意思（Gabage Collection）,内存处理是编程人员容易出现问题的地方，忘记或者错误的内存回收会导致程序或系统的不稳定甚至崩溃，Java提供的GC功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的，Java语言没有提供释放已分配内存的显示操作方法。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">要请求垃圾收集，可以调用下面的方法之一：  </span><br><span class="line"><span class="selector-tag">System</span><span class="selector-class">.gc</span>() </span><br><span class="line"><span class="selector-tag">Runtime</span><span class="selector-class">.getRuntime</span>()<span class="selector-class">.gc</span>()</span><br></pre></td></tr></table></figure></p><p>当然，如果需要，程序员可以在Java程序中显式地使用System.gc()来强制进行一次立即的内存清理。<br>因为显式声明是做堆内存全扫描，也就是FullGC，是需要停止所有的活动的（Stop The World Collection），你的应用能承受这个吗？而其显示调用System.gc()只是给虚拟机一个建议，不一定会执行，因为System.gc()在一个优先级很低的线程中执行。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Java基础面试题五&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Q1: &amp;amp; 和 &amp;amp;&amp;amp; 的区别&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;amp;是位运算符，表示按位与运算，&amp;amp;&amp;amp;是逻辑运算符，表示逻辑与（and）。&lt;/p&gt;
&lt;block
      
    
    </summary>
    
      <category term="Java" scheme="https://wxzhongwang.github.io/categories/Java/"/>
    
    
      <category term="面试题" scheme="https://wxzhongwang.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Java基础面试题二</title>
    <link href="https://wxzhongwang.github.io/2019/08/07/Java%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98%E4%BA%8C/"/>
    <id>https://wxzhongwang.github.io/2019/08/07/Java基础面试题二/</id>
    <published>2019-08-07T14:37:25.984Z</published>
    <updated>2019-08-11T05:16:06.958Z</updated>
    
    <content type="html"><![CDATA[<p>Java基础面试题二</p><blockquote><p>Q1: 什么是死锁(deadlock)？ </p></blockquote><p>两个进程都在等待对方执行完毕才能继续往下执行的时候就发生了死锁。结果就是两个进程都陷入了无限的等待中。<br>代码表示：<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DieLockDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> void main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line">    DieLock dl1 = <span class="keyword">new</span> <span class="type">DieLock</span>(<span class="literal">true</span>);</span><br><span class="line">    DieLock dl2 = <span class="keyword">new</span> <span class="type">DieLock</span>(<span class="literal">false</span>);</span><br><span class="line">    dl1.start();</span><br><span class="line">    dl2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>理想状态下dl1线程为true从if执行先打出”if objA”然后再接着打出”if objB”之后释放A、B的锁对象，之后dl2线程执行else语句打出”else objB”，”else objA”。<br>非理想状态下dl1先打出”if objA”，之后线程dl2执行打出”else objB”，然后1、2线程的锁对象A和B都处于被锁的状态，两个线程争夺锁对象发生死锁现象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DieLock</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> flag;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DieLock</span><span class="params">(<span class="keyword">boolean</span> flag)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.flag = flag;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (MyLock.objA) &#123;</span><br><span class="line">                System.out.println(<span class="string">"if objA"</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (MyLock.objB) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"if objB"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (MyLock.objB) &#123;</span><br><span class="line">                System.out.println(<span class="string">"else objB"</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (MyLock.objA) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"else objA"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Java基础面试题二&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Q1: 什么是死锁(deadlock)？ &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;两个进程都在等待对方执行完毕才能继续往下执行的时候就发生了死锁。结果就是两个进程都陷入了无限的等待中。&lt;br&gt;代码表示：&lt;br
      
    
    </summary>
    
      <category term="Java" scheme="https://wxzhongwang.github.io/categories/Java/"/>
    
    
      <category term="面试题" scheme="https://wxzhongwang.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Java基础面试题三</title>
    <link href="https://wxzhongwang.github.io/2019/08/07/Java%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B8%89/"/>
    <id>https://wxzhongwang.github.io/2019/08/07/Java基础面试题三/</id>
    <published>2019-08-07T14:37:25.984Z</published>
    <updated>2019-08-11T05:16:03.862Z</updated>
    
    <content type="html"><![CDATA[<p>Java基础面试题三</p><blockquote><p>Q1: 如何确保N个线程可以访问N个资源同时又不导致死锁？ </p></blockquote><p>使用多线程的时候，一种非常简单的避免死锁的方式就是：指定获取锁的顺序，并强制线程按照指定的顺序获取锁。因此，如果所有的线程都是以同样的顺序加锁和释放锁，就不会出现死锁了。</p><blockquote><p>Q2: Java集合类框架的基本接口有哪些？</p></blockquote><p>Java集合类提供了一套设计良好的支持对一组对象进行操作的接口和类。<br>Java集合类里面最基本的接口有： </p><ul><li>Collection：代表一组对象，每一个对象都是它的子元素。 </li><li>Set：不包含重复元素的Collection。 </li><li>List：有顺序的collection，并且可以包含重复元素。 </li><li>Map：可以把键(key)映射到值(value)的对象，键不能重复。</li></ul><blockquote><p>Q3: 什么是迭代器(Iterator)？ </p></blockquote><p>Iterator接口提供了很多对集合元素进行迭代的方法。每一个集合类都包含了可以返回迭代器实例的迭代方法。迭代器可以在迭代的过程中删除底层集合的元素。</p><blockquote><p>Q4: Iterator和ListIterator的区别是什么？</p></blockquote><p>下面列出了他们的区别： </p><ul><li>Iterator可用来遍历Set和List集合，但是ListIterator只能用来遍历List。 </li><li>Iterator对集合只能是前向遍历，ListIterator既可以前向也可以后向。 </li><li>ListIterator实现了Iterator接口，并包含其他的功能，比如：增加元素，替换元素，获取前一个和后一个元素的索引，等等。</li></ul><blockquote><p>Q5: Java中的HashMap的工作原理是什么？ </p></blockquote><p>Java中的HashMap是以键值对(key-value)的形式存储元素的。HashMap需要一个hash函数，它使用hashCode()和equals()方法来向集合/从集合添加和检索元素。当调用put()方法的时候，HashMap会计算key的hash值，然后把键值对存储在集合中合适的索引上。如果key已经存在了，value会被更新成新值。</p><p>HashMap的一些重要的特性是它的容量(capacity)，负载因子(load factor)和扩容极限(threshold resizing)。</p><blockquote><p>Q6: HashMap和Hashtable有什么区别？ </p></blockquote><ul><li>HashMap和Hashtable都实现了Map接口，因此很多特性非常相似。但是，他们有以下不同点： </li><li>HashMap允许键和值是null，而Hashtable不允许键或者值是null。 </li><li>Hashtable是同步的，而HashMap不是。因此，HashMap更适合于单线程环境，而Hashtable适合于多线程环境。 </li><li>HashMap提供了可供应用迭代的键的集合，因此，HashMap是快速失败的。另一方面，Hashtable提供了对键的列举(Enumeration)。 </li></ul><blockquote><p>Q7: 数组(Array)和列表(ArrayList)有什么区别？什么时候应该使用Array而不是ArrayList？ </p></blockquote><p>下面列出了Array和ArrayList的不同点： </p><ul><li>Array可以包含基本类型和对象类型，ArrayList只能包含对象类型。 </li><li>Array大小是固定的，ArrayList的大小是动态变化的。 </li><li>ArrayList提供了更多的方法和特性，比如：addAll()，removeAll()，iterator()等等。 </li><li>对于基本类型数据，集合使用自动装箱来减少编码工作量。但是，当处理固定大小的基本数据类型的时候，这种方式相对比较慢。</li></ul><blockquote><p>Q8: ArrayList和LinkedList有什么区别？ </p></blockquote><p>ArrayList和LinkedList都实现了List接口，他们有以下的不同点： </p><ul><li>ArrayList是基于索引的数据接口，它的底层是数组。它可以以O(1)时间复杂度对元素进行随机访问。与此对应，LinkedList是以元素链表的形式存储它的数据，每一个元素都和它的前一个和后一个元素链接在一起，在这种情况下，查找某个元素的时间复杂度是O(n)。 </li><li>相对于ArrayList，LinkedList的插入，添加，删除操作速度更快，因为当元素被添加到集合任意位置的时候，不需要像数组那样重新计算大小或者是更新索引。 </li><li>LinkedList比ArrayList更占内存，因为LinkedList为每一个节点存储了两个引用，一个指向前一个元素，一个指向下一个元素。也可以参考ArrayList vs. LinkedList。</li></ul><blockquote><p>Q9: 如何权衡是使用无序的数组还是有序的数组？ </p></blockquote><p>有序数组最大的好处在于查找的时间复杂度是O(log n)，而无序数组是O(n)。有序数组的缺点是插入操作的时间复杂度是O(n)，因为值大的元素需要往后移动来给新元素腾位置。相反，无序数组的插入时间复杂度是常量O(1)。</p><blockquote><p>Q10: HashSet和TreeSet有什么区别？ </p></blockquote><p>HashSet是由一个hash表来实现的，因此，它的元素是无序的。add()，remove()，contains()方法的时间复杂度是O(1)。 </p><p>TreeSet是由一个树形的结构来实现的，它里面的元素是有序的。因此，add()，remove()，contains()方法的时间复杂度是O(logn)。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Java基础面试题三&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Q1: 如何确保N个线程可以访问N个资源同时又不导致死锁？ &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;使用多线程的时候，一种非常简单的避免死锁的方式就是：指定获取锁的顺序，并强制线程按照指定的顺序获取锁。因此，
      
    
    </summary>
    
      <category term="Java" scheme="https://wxzhongwang.github.io/categories/Java/"/>
    
    
      <category term="面试题" scheme="https://wxzhongwang.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Java基础面试题一</title>
    <link href="https://wxzhongwang.github.io/2019/08/07/Java%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>https://wxzhongwang.github.io/2019/08/07/Java基础面试题/</id>
    <published>2019-08-07T14:37:25.983Z</published>
    <updated>2019-08-11T05:15:59.742Z</updated>
    
    <content type="html"><![CDATA[<p>Java基础面试题</p><blockquote><p>Q1: 什么是Java虚拟机?</p></blockquote><p>Java虚拟机是一个可以执行Java字节码的虚拟机进程。Java源文件被编译成能被Java虚拟机执行的字节码文件。</p><blockquote><p>Q2: “static”关键字是什么意思？Java中是否可以覆盖(override)一个private或者是static的方法？</p></blockquote><p>“static”关键字表明一个成员变量或者是成员方法可以在没有所属的类的实例变量的情况下被访问。简单说就是：不声明所属类的实例就可访问该变量或方法。Java中static方法不能被覆盖，因为方法覆盖是基于运行时动态绑定的，而static方法是编译时静态绑定的。</p><blockquote><p>Q3: 是否可以在static环境中访问非static变量？ </p></blockquote><p>static变量在Java中是属于类的，它在所有的实例中的值是一样的。当类被Java虚拟机载入的时候，会对static变量进行初始化。如果你的代码尝试不用实例来访问非static的变量，编译器会报错，因为这些变量还没有被创建出来，还没有跟任何实例关联上。</p><blockquote><p>Q4: Java支持的数据类型有哪些？什么是自动拆装箱？ </p></blockquote><p>基本数据类型是： </p><ul><li>byte </li><li>short </li><li>int </li><li>long </li><li>float </li><li>double </li><li>boolean </li><li>char </li></ul><p>自动装箱是Java编译器在基本数据类型和对应的对象包装类型之间做的一个转化。比如：把int转化成Integer，float转化成double，等等。反之就是自动拆箱。</p><blockquote><p>Q5: Overload和Override的区别。Overloaded的方法是否可以改变返回值的类型? </p></blockquote><p>方法的重写Overriding和重载Overloading是Java多态性的不同表现。重写Overriding是父类与子类之间多态性的一种表现，重载Overloading是一个类中多态性的一种表现。如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写(Overriding)。子类的对象使用这个方法时，将调用子类中的定义，对它而言，父类中的定义如同被”屏蔽”了。如果在一个类中定义了多个同名的方法，它们或有不同的参数个数或有不同的参数类型，则称为方法的重载(Overloading)。Overloaded的方法是可以改变返回值的类型。</p><p>Overload： 重写 子类重写父类方法<br>Overload:  重载 相同方法名</p><blockquote><p>Q6: Java支持多继承么？ </p></blockquote><p>不支持，Java不支持多继承。每个类都只能继承一个类，但是可以实现多个接口。</p><blockquote><p>Q7: 接口和抽象类的区别是什么？ </p></blockquote><p>Java提供和支持创建抽象类和接口。它们的实现有共同点，不同点在于： </p><ul><li>接口中所有的方法隐含的都是抽象的。而抽象类则可以同时包含抽象和非抽象的方法。 </li><li>类可以实现很多个接口，但是只能继承一个抽象类 </li><li>类如果要实现一个接口，它必须要实现接口声明的所有方法。但是，类可以不实现抽象类声明的所有方法，当然，在这种情况下，类也必须得声明成是抽象的。 </li><li>抽象类可以在不提供接口方法实现的情况下实现接口。 </li><li>Java接口中声明的变量默认都是final的。抽象类可以包含非final的变量。 </li><li>Java接口中的成员函数默认是public的。抽象类的成员函数可以是private，protected或者是public。 </li><li>接口是绝对抽象的，不可以被实例化。抽象类也不可以被实例化，但是，如果它包含main方法的话是可以被调用的。</li></ul><blockquote><p>Q8: 什么是值传递和引用传递？</p></blockquote><p>值传递: 意味着传递了对象的一个副本。因此，就算是改变了对象副本，也不会影响源对象的值。 </p><p>引用传递: 意味着传递的并不是实际的对象，而是对象的引用。因此，外部对引用对象所做的改变会反映到所有的对象上。</p><blockquote><p>Q9: 创建线程有几种不同的方式？你喜欢哪一种？为什么？</p></blockquote><p>有三种方式可以用来创建线程： </p><ul><li>继承Thread类 </li><li>实现Runnable接口 </li><li>应用程序可以使用Executor框架来创建线程池 </li></ul><p>实现Runnable接口这种方式更受欢迎，因为这不需要继承Thread类。在应用设计中已经继承了别的对象的情况下，这需要多继承（而Java不支持多继承），只能实现接口。同时，线程池也是非常高效的，很容易实现和使用。</p><blockquote><p>Q10: 同步方法和同步代码块的区别是什么？ </p></blockquote><p>在Java语言中，每一个对象有一把锁。线程可以使用synchronized关键字来获取对象上的锁。<br>synchronized关键字可应用在方法级别(粗粒度锁：这里的锁对象可以是This)或者是代码块级别(细粒度锁：这里的锁对象就是任意对象)。</p><ul><li>方法级别(粗粒度锁：这里的锁对象可以是This)</li><li>代码块级别(细粒度锁：这里的锁对象就是任意对象)</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Java基础面试题&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Q1: 什么是Java虚拟机?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Java虚拟机是一个可以执行Java字节码的虚拟机进程。Java源文件被编译成能被Java虚拟机执行的字节码文件。&lt;/p&gt;
&lt;blockqu
      
    
    </summary>
    
      <category term="Java" scheme="https://wxzhongwang.github.io/categories/Java/"/>
    
    
      <category term="面试题" scheme="https://wxzhongwang.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Git安装</title>
    <link href="https://wxzhongwang.github.io/2019/08/07/Git%E5%AE%89%E8%A3%85/"/>
    <id>https://wxzhongwang.github.io/2019/08/07/Git安装/</id>
    <published>2019-08-07T14:37:25.977Z</published>
    <updated>2019-06-27T11:04:56.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux-安装Git"><a href="#Linux-安装Git" class="headerlink" title="Linux 安装Git:"></a>Linux 安装Git:</h1><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">检查是否安装Git</span><br><span class="line">git --version </span><br><span class="line"></span><br><span class="line">在 Ubuntu 这类 Debian 体系的系统上，可以用 apt-<span class="builtin-name">get</span> 安装：</span><br><span class="line">sudo apt-<span class="builtin-name">get</span> install git</span><br><span class="line"></span><br><span class="line">CentOs:</span><br><span class="line">yum install -y git</span><br></pre></td></tr></table></figure><p>window安装比较简单不多说。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Linux-安装Git&quot;&gt;&lt;a href=&quot;#Linux-安装Git&quot; class=&quot;headerlink&quot; title=&quot;Linux 安装Git:&quot;&gt;&lt;/a&gt;Linux 安装Git:&lt;/h1&gt;&lt;figure class=&quot;highlight routeros&quot;&gt;
      
    
    </summary>
    
      <category term="Git" scheme="https://wxzhongwang.github.io/categories/Git/"/>
    
    
      <category term="Git" scheme="https://wxzhongwang.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>NodeJs apiDoc</title>
    <link href="https://wxzhongwang.github.io/2019/08/07/apiDoc%E6%8E%A5%E5%8F%A3%E6%96%87%E6%A1%A3/"/>
    <id>https://wxzhongwang.github.io/2019/08/07/apiDoc接口文档/</id>
    <published>2019-08-07T14:37:25.972Z</published>
    <updated>2019-06-27T11:04:52.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="apiDoc"><a href="#apiDoc" class="headerlink" title="apiDoc"></a>apiDoc</h1><p>全局安装，方便用命令创建文档<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">install</span> apidoc -g</span><br></pre></td></tr></table></figure></p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>在你的项目根目录下新建apidoc.json文件，该文件描述了项目对外提供接口的概要信息如名称、版本、描述、文档打开时浏览器显示标题和接口缺省访问地址。<br>apidoc.json</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"xxx Api"</span>, </span><br><span class="line">    <span class="string">"version"</span>: <span class="string">"1.0.0"</span>, </span><br><span class="line">    <span class="string">"description"</span>: <span class="string">"xxx Api Documentation"</span>, </span><br><span class="line">    <span class="string">"title"</span>: <span class="string">"xxx"</span>,  </span><br><span class="line">    <span class="string">"url"</span> : <span class="string">"http://域名/api/v1"</span>,</span><br><span class="line">    <span class="string">"sampleUrl"</span>: <span class="string">"http://域名/api/v1"</span>,</span><br><span class="line"></span><br><span class="line">    <span class="string">"template"</span>: &#123;</span><br><span class="line">      <span class="string">"withCompare"</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="string">"withGenerator"</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="string">"forceLanguage"</span>:<span class="string">"en"</span></span><br><span class="line">    &#125;,</span><br><span class="line">  //顺序、若有需要可配置(<span class="name">books</span>, student,xxx) Resources Name</span><br><span class="line">  <span class="string">"order"</span>: [<span class="string">"xxx"</span>,<span class="string">"xxx"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a>Sample</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown">/**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>Get Access Token</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@api &#123;POST&#125; /token GetAccessToken</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@apiDescription Generate </span>a<span class="markdown"> token that can be passed with each API request.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@apiName GetAccessToken</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@apiPermission API User</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@apiParam (Parameters) &#123;String&#125; username username</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@apiParam (Parameters) &#123;String&#125; password password</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@apiParamExample &#123;json&#125; Sample (Request body formats: text/plain, application/x-www-form-urlencoded, text/json, application/json)  :</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>&#123;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *   </span>"username": "</span>your<span class="markdown"> accont",</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *   </span>"password": "</span>your<span class="markdown"> password"</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>&#125;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@apiSampleRequest off</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@apiSuccessExample &#123;json&#125; Response (Response body formats: application/json, text/json):</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>Success Response :</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>Status: 200 OK</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>&#123;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *   </span>"status": "success",</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *   </span>"message": "Authentication successful.",</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *   </span>"data": &#123;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *      </span>"token": "eyJhbGciOiJIUzI1NiIsInR5cCI6Ikpxxxxx.xxxxx2VybmFtZSI6InNsIiwiaWF0IjoxNTQ1MTkyMzY4LCJleHAiOjE1NDUxOTI4NDh9.xxxxxxgS1Yw8rNRD31p97A7fdWvmkrXxo3llMJowX7U"</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *   </span>&#125;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>&#125;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>Or </span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>Bad Response:</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>Status: 400 </span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>&#123; </span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *   </span>"status": "failure", </span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *   </span>"message": "Authentication failed. Please provide </span>a<span class="markdown"> correct username or password."</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>&#125; </span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@apiGroup Token</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@apiVersion 1.0.0</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> */</span></span></span><br></pre></td></tr></table></figure><h2 id="生成"><a href="#生成" class="headerlink" title="生成"></a>生成</h2><p>文档初始化或发生改变时，在应用程序根目录执行相应命令<br>以此项目为例：</p><blockquote><p>apidoc -i api/v1 -o public/apiDoc</p></blockquote><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-<span class="selector-tag">i</span> input</span><br><span class="line">-o output</span><br><span class="line"></span><br><span class="line">指定文件夹路径</span><br></pre></td></tr></table></figure><p>具体注释写法参照官网解释：<br><a href="http://apidocjs.com/#run" target="_blank" rel="noopener">http://apidocjs.com/#run</a></p><p>public/apiDoc内文件不用上传到代码管理中<br>可直接执行npm run doc命令自动生成</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;apiDoc&quot;&gt;&lt;a href=&quot;#apiDoc&quot; class=&quot;headerlink&quot; title=&quot;apiDoc&quot;&gt;&lt;/a&gt;apiDoc&lt;/h1&gt;&lt;p&gt;全局安装，方便用命令创建文档&lt;br&gt;&lt;figure class=&quot;highlight cmake&quot;&gt;&lt;tab
      
    
    </summary>
    
      <category term="NodeJs" scheme="https://wxzhongwang.github.io/categories/NodeJs/"/>
    
    
      <category term="NodeJs" scheme="https://wxzhongwang.github.io/tags/NodeJs/"/>
    
  </entry>
  
  <entry>
    <title>大数据</title>
    <link href="https://wxzhongwang.github.io/2019/04/08/%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%8F%B0%E5%92%8C%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93%E3%80%81%E6%95%B0%E6%8D%AE%E5%B9%B3%E5%8F%B0/"/>
    <id>https://wxzhongwang.github.io/2019/04/08/数据中台和数据仓库、数据平台/</id>
    <published>2019-04-08T06:25:45.000Z</published>
    <updated>2019-06-27T11:05:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据中台和数据仓库、数据平台的关键区别？"><a href="#数据中台和数据仓库、数据平台的关键区别？" class="headerlink" title="数据中台和数据仓库、数据平台的关键区别？"></a>数据中台和数据仓库、数据平台的关键区别？</h1><p>概括地说，三者的关键区别有以下几方面：</p><p>数据中台是企业级的逻辑概念，体现企业 D2V（Data to Value）的能力，为业务提供服务的主要方式是数据 API；</p><p>数据仓库是一个相对具体的功能概念，是存储和管理一个或多个主题数据的集合，为业务提供服务的方式主要是分析报表；</p><p>数据平台是在大数据基础上出现的融合了结构化和非结构化数据的数据基础平台，为业务提供服务的方式主要是直接提供数据集；</p><p>数据中台距离业务更近，为业务提供速度更快的服务；</p><p>数据仓库是为了支持管理决策分析，而数据中台则是将数据服务化之后提供给业务系统，不仅限于分析型场景，也适用于交易型场景；</p><p>数据中台可以建立在数据仓库和数据平台之上，是加速企业从数据到业务价值的过程的中间层。</p><p>数据仓库具有历史性，其中存储的数据大多是结构化数据，这些数据并非企业全量数据，而是根据需求针对性抽取的，</p><p>因此数据仓库对于业务的价值是各种各样的报表，但这些报表又无法实时产生。数据仓库报表虽然能够提供部分业务价值，但不能直接影响业务。</p><p>数据平台的出现是为了解决数据仓库不能处理非结构化数据和报表开发周期长的问题，所以先撇开业务需求、把企业所有的数据都抽取出来放到一起，成为一个大的数据集，其中有结构化数据、非结构化数据等。</p><p>当业务方有需求的时候，再把他们需要的若干个小数据集单独提取出来，以数据集的形式提供给数据应用。</p><p>而数据中台是在数据仓库和数据平台的基础上，将数据生产为为一个个数据 API 服务，以更高效的方式提供给业务。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数据中台和数据仓库、数据平台的关键区别？&quot;&gt;&lt;a href=&quot;#数据中台和数据仓库、数据平台的关键区别？&quot; class=&quot;headerlink&quot; title=&quot;数据中台和数据仓库、数据平台的关键区别？&quot;&gt;&lt;/a&gt;数据中台和数据仓库、数据平台的关键区别？&lt;/h1&gt;&lt;
      
    
    </summary>
    
      <category term="大数据" scheme="https://wxzhongwang.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="大数据" scheme="https://wxzhongwang.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title>编码规范</title>
    <link href="https://wxzhongwang.github.io/2019/03/31/%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    <id>https://wxzhongwang.github.io/2019/03/31/编码规范/</id>
    <published>2019-03-31T03:18:02.000Z</published>
    <updated>2019-08-08T13:14:06.287Z</updated>
    
    <content type="html"><![CDATA[<h1 id="编码规范"><a href="#编码规范" class="headerlink" title="编码规范"></a>编码规范</h1><h2 id="C-编码风格指南"><a href="#C-编码风格指南" class="headerlink" title="C# 编码风格指南"></a>C# 编码风格指南</h2><p>一旦进入代码开发阶段，你必须安排好代码审查计划以确保每个人都遵守同样的规则。建议按以下3种方式进行代码审查：</p><ol><li><p>互相审查 - 由其他团队成员进行代码审查以确保遵守了代码规范且达到要求。这种方式可以配合单元测试。项目中每个代码文件必须要通过这个程序。</p></li><li><p>架构审查 - 架构人员需对项目核心模块进行审查以确保符合设计，没有出现大的甚至有可能影响整个项目运转的纰漏。</p></li><li><p>团队审查 - 每周随机选择一个或多个文件进行一次团队审查。审查会议开始前30分钟，将文件打印并分发到每个成员手里，会议开始后用投影仪将文件内容展示出来。代码的每一块都要进行审查，让所有成员提出改进建议。（别忘了要感谢提供素材的开发人员，并确保他不会觉得受到了“群嘲”！）</p></li></ol><h2 id="代码文件组织"><a href="#代码文件组织" class="headerlink" title="代码文件组织"></a>代码文件组织</h2><h3 id="C-源代码文件"><a href="#C-源代码文件" class="headerlink" title="C# 源代码文件"></a>C# 源代码文件</h3><p>每个源代码文件应该只包含一个类定义，也即类定义只出现在它自己的文件中。源代码文件名需与类声明里的类名保持一致。<br>譬如一个名为User的类的源文件名应该是User.cs。</p><h3 id="版权声明"><a href="#版权声明" class="headerlink" title="版权声明"></a>版权声明</h3><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//-------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// Copyright (c) Dick. All Right Reserved. </span></span><br><span class="line"><span class="comment">// This source is subject to the Microsoft Permissive License. </span></span><br><span class="line"><span class="comment">// Please see the License.txt file for more information. </span></span><br><span class="line"><span class="comment">// All other rights reserved. </span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY </span></span><br><span class="line"><span class="comment">// KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE </span></span><br><span class="line"><span class="comment">// IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A </span></span><br><span class="line"><span class="comment">// PARTICULAR PURPOSE. </span></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------</span></span><br></pre></td></tr></table></figure><h3 id="目录设计"><a href="#目录设计" class="headerlink" title="目录设计"></a>目录设计</h3><p>每层命名空间都要建立目录（以MyProject.UI.Admin为例，请使用MyProject/UI/Admin这样的目录结构，而不是只建立一层名为MyProject.UI.Admin的目录）。</p><h3 id="代码排列"><a href="#代码排列" class="headerlink" title="代码排列"></a>代码排列</h3><p>C#源代码文件整体顺序应为：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Using 声明</span><br><span class="line">Namespace声明</span><br><span class="line">Class 和<span class="built_in"> interface </span>声明</span><br></pre></td></tr></table></figure></p><p>C#类内部分的顺序应为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">成员变量</span><br><span class="line">属性</span><br><span class="line">构造函数</span><br><span class="line">方法</span><br><span class="line">`</span><br></pre></td></tr></table></figure></p><blockquote><p>以上每个部分都需要放到 #region里。</p></blockquote><h3 id="命名空间和USING声明"><a href="#命名空间和USING声明" class="headerlink" title="命名空间和USING声明"></a>命名空间和USING声明</h3><ol><li>Using 和命名空间声明都要左边界齐平。</li><li>命名空间的每个组件名首字母要大写</li><li>如果组件名是个缩写，只让第一个字母大写，如 System.Data.Sql。</li><li>如果这个缩写只有2个字母，那可以2个字母都大写，如 System.IO。</li></ol><p>注意: 移除不需要的或重复的命名空间，使用短的命名空间来代替。譬如：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Preferred</span></span><br><span class="line"><span class="keyword">using</span> System.Data.SqlClient;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ValidationCall</span><span class="params">()</span></span>&#123;  </span><br><span class="line">… </span><br><span class="line">SqlConnection conn = <span class="keyword">new</span> SqlConnection(connstr);</span><br><span class="line">…</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Avoid</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ValidationCall</span><span class="params">()</span></span>&#123;  </span><br><span class="line">… </span><br><span class="line">System.Data.SqlClient.SqlConnection conn = <span class="keyword">new</span> SqlConnection(connstr);</span><br><span class="line">…</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="创建和修订记录"><a href="#创建和修订记录" class="headerlink" title="创建和修订记录"></a>创建和修订记录</h3><p>文件创建和修订记录需要按以下格式填写到using代码段后面，namespace之前。<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/<span class="strong">*</span></span><br><span class="line"><span class="strong">*</span> 作者:                创建日期:</span><br><span class="line"><span class="bullet">* </span>修订者：             修订日期：               修订内容：</span><br><span class="line"><span class="bullet">* </span></span><br><span class="line"><span class="strong">*/</span></span><br></pre></td></tr></table></figure></p><h3 id="XML-文档"><a href="#XML-文档" class="headerlink" title="XML 文档"></a>XML 文档</h3><p>Visual Studio提供了一种文档类型，在开发环境中可以用来检测并导出到结构化的XML中，以用来创建与源代码分离的代码级别的文档。<br>XML 文档用于描述类、方法和属性。它应当在所有可用的情况下尽可能使用。</p><h2 id="缩进"><a href="#缩进" class="headerlink" title="缩进"></a>缩进</h2><h3 id="空行"><a href="#空行" class="headerlink" title="空行"></a>空行</h3><p>适当的空行能增强代码可读性。它们能帮助区分逻辑不相干的代码片段。<br>双行空行要放在：<br>源代码中逻辑不相关的代码片段之间<br>不同的类和接口定义（如果有时候不得不放在同个文件，尽量避免这种情况）<br>单行空行要放在：</p><ul><li>方法与方法之间</li><li>属性与属性之间</li><li>方法体内的局部变量和它的第一次使用之间</li><li>方法体内不同逻辑片段之间以增强可读性</li></ul><h3 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h3><p>如果一个表达式在一行内放不下，则根据以下常用原则来进行换行：</p><ol><li>操作符号之后换行</li><li>逗号之后换行</li><li>择较高等的换行，其次才是较低等的换行 （譬如优先对括号外的部分换行）<br>换行后需要缩进<br>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用方法</span></span><br><span class="line">SomeMethod1(expression1, expression2, expression3, expression4, expression5);</span><br><span class="line"><span class="comment">// 声明方法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SomeMethod1</span><span class="params">(<span class="keyword">long</span> Expression1, <span class="keyword">long</span> Expression2, <span class="keyword">long</span> Expression3,                 <span class="keyword">long</span> Expression4, <span class="keyword">long</span> Expression5)</span></span></span><br><span class="line"><span class="function"></span>&#123;     </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>注意: 换行后第二行的缩进与第一个参数齐平<br>以下是一个数学表达式换行的例子。第一种换行方式是较好的，因为是在括号以外的地方进行的换行，也即是在较高等进行的分行。</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Preferred</span></span><br><span class="line">var<span class="number">1</span> = var<span class="number">2</span> * <span class="comment">(var3 + var4 – var5)</span> + </span><br><span class="line">       var<span class="number">4</span> * var<span class="number">6</span>;</span><br><span class="line"><span class="comment">// Avoid</span></span><br><span class="line">var<span class="number">1</span> = var<span class="number">2</span> * <span class="comment">(var3 + var4 - var5)</span> + var<span class="number">4</span> * var<span class="number">6</span>;</span><br></pre></td></tr></table></figure><p>对if表达式的分行需要使用缩进：<br><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="comment">((condition1 &amp;&amp; condition2)</span> || <span class="comment">(condition3 &amp;&amp; condition4)</span> &amp;&amp; co<span class="symbol">ndition5</span> || !co<span class="symbol">ndition6</span>)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>三元表达式请用这两种格式：<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Alpha</span> = aLongBooleanExpression ? beta : gamma;</span><br><span class="line"><span class="attribute">Alpha</span> = aLongBooleanExpression ?</span><br><span class="line">        beta : </span><br><span class="line">        gamma;</span><br></pre></td></tr></table></figure></p><h2 id="代码间距"><a href="#代码间距" class="headerlink" title="代码间距"></a>代码间距</h2><h3 id="空格间距"><a href="#空格间距" class="headerlink" title="空格间距"></a>空格间距</h3><p>在代码中间的逗号或分号后应该有单独的一个空格，此外一个关键字与后跟的括号之间也要有个空格，譬如：<br><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Correct</span></span><br><span class="line">TestMethod<span class="comment">(a, b, c)</span>;</span><br><span class="line"><span class="keyword">while</span> <span class="comment">(condition)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//... </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Avoid</span></span><br><span class="line">TestMethod<span class="comment">(a, b, c)</span>;</span><br><span class="line">TestMethod<span class="comment">(a, b, c)</span>;</span><br></pre></td></tr></table></figure></p><p>注意: 在方法名和它的前括号之间不需要有空格。这样便于区分是关键字还是方法名。<br>操作符两边要加上空格（++或逻辑非这样的一元运算符除外），譬如：<br><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = b; <span class="regexp">//</span> Avoid a=b;</span><br><span class="line"></span><br><span class="line">// Avoid <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; ++i) <span class="keyword">or</span> <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;++i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="TAB间距"><a href="#TAB间距" class="headerlink" title="TAB间距"></a>TAB间距</h3><p>该使用几个空格作为代码缩进距离从来没有达成一致过。有人喜欢2个空格，有人喜欢4个而有人喜欢8个甚至更多。所以最好使用Tab缩进。它的好处有：<br>可以自定义缩进距离<br>它只需一个字符，所以只要按一次键而不是2,4,8…</p><p>如果你要增加缩进（或减少）一片代码，可以选中它们然后按Tab来增加或者Shift+Tab来减少缩进。几乎所有文本编辑器都支持这个操作。<br>在这里Tab指的就是标准的缩进字符。<br>注意： 不要使用空格来缩进代码-用Tab！在VS中把Tab配置成4个空格的距离。</p><h2 id="一般注释"><a href="#一般注释" class="headerlink" title="一般注释"></a>一般注释</h2><h3 id="通用注释前缀"><a href="#通用注释前缀" class="headerlink" title="通用注释前缀"></a>通用注释前缀</h3><p>TODO : 表示以后别忘了在这里还需要进一步处理<br>BUG: [bugid]：表示这里有个已知bug，解释一下bug情况，如果可以则给出bug id。<br>KLUDGE: 表示这里的代码有点糟糕，解释一下有时间的话将如何改进。<br>TRICKY: 表示以下代码比较奇技淫巧，如果没有仔细思考请不要改动。<br>WARNING: 表示当心某事<br>COMPILER: 表示临时注释掉某些影响编译通过的代码。这些问题最终会被解决的。<br>ATTRIBUTE: value：嵌在注释中的属性的一般形式。你可以自定义属性，它们最终会被VS提取。</p><h3 id="单行注释"><a href="#单行注释" class="headerlink" title="单行注释"></a>单行注释</h3><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//Console.WriteLine(<span class="string">"哈哈"</span>)<span class="comment">;</span></span><br><span class="line">//Console.ReadKey()<span class="comment">;</span></span><br></pre></td></tr></table></figure><h3 id="多行注释"><a href="#多行注释" class="headerlink" title="多行注释"></a>多行注释</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"><span class="bullet"> * </span>注释内容</span><br><span class="line"><span class="bullet"> * </span>注释内容</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><h3 id="文档注释"><a href="#文档注释" class="headerlink" title="文档注释"></a>文档注释</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 文档注释</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 文档注释</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br></pre></td></tr></table></figure><h1 id="变量声明及命名规范"><a href="#变量声明及命名规范" class="headerlink" title="变量声明及命名规范"></a>变量声明及命名规范</h1><h3 id="变量："><a href="#变量：" class="headerlink" title="变量："></a>变量：</h3><p>Camel：变量名首单词的首字母小写，其余每个单词首字母单词大写,多用于给变量或字段或方法参数命名。　　<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">var str</span> = <span class="string">"123"</span>;</span><br><span class="line"><span class="attribute">var highSchoolStudent</span> = <span class="string">"123"</span>;</span><br><span class="line"><span class="attribute">int num</span> = 5;</span><br></pre></td></tr></table></figure></p><h3 id="常量："><a href="#常量：" class="headerlink" title="常量："></a>常量：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">string</span> BaseIpAddress = <span class="string">""</span>;</span><br></pre></td></tr></table></figure><h3 id="方法名："><a href="#方法名：" class="headerlink" title="方法名："></a>方法名：</h3><p>Pascal：每个单词的首字母都要大些其余小写，多用于类或方法。尽量用一般名词或动名词。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">GetHighSchoolStudent</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;编码规范&quot;&gt;&lt;a href=&quot;#编码规范&quot; class=&quot;headerlink&quot; title=&quot;编码规范&quot;&gt;&lt;/a&gt;编码规范&lt;/h1&gt;&lt;h2 id=&quot;C-编码风格指南&quot;&gt;&lt;a href=&quot;#C-编码风格指南&quot; class=&quot;headerlink&quot; title=&quot;C
      
    
    </summary>
    
      <category term="NET" scheme="https://wxzhongwang.github.io/categories/NET/"/>
    
    
      <category term="编码规范" scheme="https://wxzhongwang.github.io/tags/%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title>Java 并发基础常见面试题总结</title>
    <link href="https://wxzhongwang.github.io/2019/03/01/Java%20%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <id>https://wxzhongwang.github.io/2019/03/01/Java 并发基础常见面试题总结/</id>
    <published>2019-03-01T02:10:00.000Z</published>
    <updated>2019-08-11T05:16:33.933Z</updated>
    
    <content type="html"><![CDATA[<h1 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h1><h2 id="何为进程"><a href="#何为进程" class="headerlink" title="何为进程?"></a>何为进程?</h2><p>进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。</p><p>在 Java 中，当我们启动 main 函数时其实就是启动了一个 JVM 的进程，而 main 函数所在的线程就是这个进程中的一个线程，也称主线程。</p><h2 id="何为线程"><a href="#何为线程" class="headerlink" title="何为线程?"></a>何为线程?</h2><p>与进程不同的是同类的多个线程共享进程的堆和方法区资源，但每个线程有自己的程序计数器、虚拟机栈和本地方法栈，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。</p><p>一个 Java 程序的运行是 main 线程和多个其他线程同时运行。</p><p>一个进程中可以有多个线程，多个线程共享进程的堆和方法区，但是每个线程有自己的程序计数器、虚拟机栈 和 本地方法栈。</p><p>进程间彼此相对独立，线程则不一定，因为同一进程中的线程极有可能会相互影响。</p><h2 id="为什么程序计数器、虚拟机栈和本地方法栈是线程私有的呢？为什么堆和方法区是线程共享的呢？"><a href="#为什么程序计数器、虚拟机栈和本地方法栈是线程私有的呢？为什么堆和方法区是线程共享的呢？" class="headerlink" title="为什么程序计数器、虚拟机栈和本地方法栈是线程私有的呢？为什么堆和方法区是线程共享的呢？"></a>为什么程序计数器、虚拟机栈和本地方法栈是线程私有的呢？为什么堆和方法区是线程共享的呢？</h2><h3 id="程序计数器为什么是私有的"><a href="#程序计数器为什么是私有的" class="headerlink" title="程序计数器为什么是私有的?"></a>程序计数器为什么是私有的?</h3><p>程序计数器主要有下面两个作用：</p><p>1.字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</p><p>2.在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</p><p>需要注意的是，如果执行的是 native 方法，那么程序计数器记录的是 undefined 地址，只有执行的是 Java 代码时程序计数器记录的才是下一条指令的地址。</p><blockquote><p>所以，程序计数器私有主要是为了线程切换后能恢复到正确的执行位置。</p></blockquote><h3 id="虚拟机栈和本地方法栈为什么是私有的"><a href="#虚拟机栈和本地方法栈为什么是私有的" class="headerlink" title="虚拟机栈和本地方法栈为什么是私有的?"></a>虚拟机栈和本地方法栈为什么是私有的?</h3><p>虚拟机栈： 每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。</p><p>本地方法栈： 和虚拟机栈所发挥的作用非常相似，区别是： 虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。 </p><blockquote><p>所以，为了保证线程中的局部变量不被别的线程访问到，虚拟机栈和本地方法栈是线程私有的。</p></blockquote><h3 id="一句话简单了解堆和方法区"><a href="#一句话简单了解堆和方法区" class="headerlink" title="一句话简单了解堆和方法区"></a>一句话简单了解堆和方法区</h3><p>堆和方法区是所有线程共享的资源，其中堆是进程中最大的一块内存，主要用于存放新创建的对象<br>(所有对象都在这里分配内存)，方法区主要用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p><h2 id="说说并发与并行的区别"><a href="#说说并发与并行的区别" class="headerlink" title="说说并发与并行的区别?"></a>说说并发与并行的区别?</h2><p>并发： 同一时间段，多个任务都在执行 (单位时间内不一定同时执行)；<br>并行： 单位时间内，多个任务同时执行。</p><h2 id="为什么要使用多线程呢"><a href="#为什么要使用多线程呢" class="headerlink" title="为什么要使用多线程呢?"></a>为什么要使用多线程呢?</h2><p>先从总体上来说：</p><p>计算机底层角度： 线程可以比作是轻量级的进程，是程序执行的最小单位,线程间的切换和调度的成本远远小于进程。另外，多核 CPU 时代意味着多个线程可以同时运行，这减少了线程上下文切换的开销。+</p><p>当代互联网发展趋势角度： 现在的系统动不动就要求百万级甚至千万级的并发量，而多线程并发编程正是开发高并发系统的基础，利用好多线程机制可以大大提高系统整体的并发能力以及性能。</p><p>再深入到计算机底层来探讨：</p><p>单核时代： 在单核时代多线程主要是为了提高 CPU 和 IO 设备的综合利用率。举个例子：当只有一个线程的时候会导致 CPU 计算时，IO 设备空闲；进行 IO 操作时，CPU 空闲。我们可以简单地说这两者的利用率目前都是 50%左右。但是当有两个线程的时候就不一样了，当一个线程执行 CPU 计算时，另外一个线程可以进行 IO 操作，这样两个的利用率就可以在理想情况下达到 100%了。</p><p>多核时代: 多核时代多线程主要是为了提高 CPU 利用率。举个例子：假如我们要计算一个复杂的任务，我们只用一个线程的话，CPU 只会一个 CPU 核心被利用到，而创建多个线程就可以让多个 CPU 核心被利用到，这样就提高了 CPU 的利用率。</p><h2 id="多线程带来的问题"><a href="#多线程带来的问题" class="headerlink" title="多线程带来的问题"></a>多线程带来的问题</h2><p>并发编程的目的就是为了能提高程序的执行效率提高程序运行速度，但是并发编程并不总是能提高程序运行速度的，而且并发编程可能会遇到很多问题，比如：内存泄漏、上下文切换、死锁还有受限于硬件和软件的资源闲置问题。</p><h2 id="线程的生命周期和状态"><a href="#线程的生命周期和状态" class="headerlink" title="线程的生命周期和状态?"></a>线程的生命周期和状态?</h2><p>线程创建之后它将处于 NEW（新建） 状态，调用 start() 方法后开始运行，线程这时候处于 READY（可运行） 状态。可运行状态的线程获得了 CPU 时间片（timeslice）后就处于 RUNNING（运行） 状态。</p><p>当线程执行 wait()方法之后，线程进入WAITING（等待）状态。进入等待状态的线程需要依靠其他线程的通知才能够返回到运行状态，而TIME_WAITING(超时等待)状态相当于在等待状态的基础上增加了超时限制，比如通过 sleep（long millis）方法或 wait（long millis）方法可以将 Java 线程置于 TIMED WAITING 状态。当超时时间到达后 Java 线程将会返回到 RUNNABLE 状态。当线程调用同步方法时，在没有获取到锁的情况下，线程将会进入到 BLOCKED（阻塞） 状态。线程在执行 Runnable 的run()方法之后将会进入到 TERMINATED（终止） 状态。</p><h2 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h2><p>多线程编程中一般线程的个数都大于 CPU 核心的个数，而一个 CPU 核心在任意时刻只能被一个线程使用，为了让这些线程都能得到有效执行，CPU 采取的策略是为每个线程分配时间片并轮转的形式。当一个线程的时间片用完的时候就会重新处于就绪状态让给其他线程使用，这个过程就属于一次上下文切换。（时间片策略）</p><p>概括来说就是：当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换会这个任务时，可以再加载这个任务的状态。任务从保存到再加载的过程就是一次上下文切换。</p><p>上下文切换通常是计算密集型的。也就是说，它需要相当可观的处理器时间，在每秒几十上百次的切换中，每次切换都需要纳秒量级的时间。所以，上下文切换对系统来说意味着消耗大量的 CPU 时间，事实上，可能是操作系统中时间消耗最大的操作。</p><p>Linux 相比与其他操作系统（包括其他类 Unix 系统）有很多的优点，其中有一项就是，其上下文切换和模式切换的时间消耗非常少。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;进程和线程&quot;&gt;&lt;a href=&quot;#进程和线程&quot; class=&quot;headerlink&quot; title=&quot;进程和线程&quot;&gt;&lt;/a&gt;进程和线程&lt;/h1&gt;&lt;h2 id=&quot;何为进程&quot;&gt;&lt;a href=&quot;#何为进程&quot; class=&quot;headerlink&quot; title=&quot;何为进程?
      
    
    </summary>
    
      <category term="Java" scheme="https://wxzhongwang.github.io/categories/Java/"/>
    
    
      <category term="多线程" scheme="https://wxzhongwang.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>字符型常量和字符串常量的区别</title>
    <link href="https://wxzhongwang.github.io/2019/03/01/%E5%AD%97%E7%AC%A6%E5%9E%8B%E5%B8%B8%E9%87%8F%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://wxzhongwang.github.io/2019/03/01/字符型常量和字符串常量的区别/</id>
    <published>2019-03-01T02:10:00.000Z</published>
    <updated>2019-08-12T13:03:07.878Z</updated>
    
    <content type="html"><![CDATA[<h1 id="字符型常量和字符串常量的区别"><a href="#字符型常量和字符串常量的区别" class="headerlink" title="字符型常量和字符串常量的区别"></a>字符型常量和字符串常量的区别</h1><p>形式上: 字符常量是单引号引起的一个字符; 字符串常量是双引号引起的若干个字符</p><p>含义上: 字符常量相当于一个整型值( ASCII 值),可以参加表达式运算; 字符串常量代表一个地址值(该字符串在内存中存放位置)</p><p>占内存大小: 字符常量只占2个字节; 字符串常量占若干个字节(至少一个字符结束标志) (注意： char在Java中占两个字节)</p><p>数据类型     大小        包装器类型<br>boolean      -           Boolean<br>char       16bits        Character<br>byte        8bits        Byte<br>short      16bits        Short<br>int        32bits        Integer<br>long       64bits        Long<br>float      32bits        Float<br>double     64bits        Double</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;字符型常量和字符串常量的区别&quot;&gt;&lt;a href=&quot;#字符型常量和字符串常量的区别&quot; class=&quot;headerlink&quot; title=&quot;字符型常量和字符串常量的区别&quot;&gt;&lt;/a&gt;字符型常量和字符串常量的区别&lt;/h1&gt;&lt;p&gt;形式上: 字符常量是单引号引起的一个字符; 
      
    
    </summary>
    
      <category term="Java" scheme="https://wxzhongwang.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://wxzhongwang.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java 并发进阶常见面试题总结</title>
    <link href="https://wxzhongwang.github.io/2019/03/01/Java%20%E5%B9%B6%E5%8F%91%E8%BF%9B%E9%98%B6%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <id>https://wxzhongwang.github.io/2019/03/01/Java 并发进阶常见面试题总结/</id>
    <published>2019-03-01T02:10:00.000Z</published>
    <updated>2019-08-12T12:10:10.757Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-并发进阶常见面试题总结"><a href="#Java-并发进阶常见面试题总结" class="headerlink" title="Java 并发进阶常见面试题总结"></a>Java 并发进阶常见面试题总结</h1><h2 id="synchronized-关键字"><a href="#synchronized-关键字" class="headerlink" title="synchronized 关键字"></a>synchronized 关键字</h2><p>synchronized关键字解决的是多个线程之间访问资源的同步性，synchronized关键字可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。<br>(后半句) 任意时刻只有一个线程在访问</p><p>在 Java 早期版本中，synchronized属于重量级锁，效率低下，因为监视器锁（monitor）是依赖于底层的操作系统的 Mutex Lock 来实现的，Java 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高，这也是为什么早期的 synchronized 效率低的原因。庆幸的是在 Java 6 之后 Java 官方对从JVM层面对synchronized较大优化，所以现在的 synchronized 锁效率也优化得很不错了。JDK1.6对锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。</p><h2 id="项目中怎么使用-synchronized-关键字"><a href="#项目中怎么使用-synchronized-关键字" class="headerlink" title="项目中怎么使用 synchronized 关键字"></a>项目中怎么使用 synchronized 关键字</h2><p>synchronized关键字最主要的三种使用方式：</p><p>修饰实例方法:<br>作用于当前对象实例加锁，进入同步代码前要获得当前对象实例的锁</p><p>修饰静态方法: 也就是给当前类加锁，会作用于类的所有对象实例，因为静态成员不属于任何一个实例对象，是类成员（ static 表明这是该类的一个静态资源，不管new了多少个对象，只有一份）。所以如果一个线程A调用一个实例对象的非静态 synchronized 方法，而线程B需要调用这个实例对象所属类的静态 synchronized 方法，是允许的，不会发生互斥现象，因为访问静态 synchronized 方法占用的锁是当前类的锁，而访问非静态 synchronized 方法占用的锁是当前实例对象锁。</p><p>修饰代码块: 指定加锁对象，对给定对象加锁，进入同步代码块前要获得给定对象的锁。</p><p>比如以下的：双重校验锁实现单例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getUniqueInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">//先判断对象是否已经实例过，没有实例化过才进入加锁代码</span></span><br><span class="line">        <span class="keyword">if</span> (uniqueInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//类对象加锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (uniqueInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><p>另外，需要注意 uniqueInstance 采用 volatile 关键字修饰也是很有必要。</p><p>uniqueInstance 采用 volatile 关键字修饰也是很有必要的， uniqueInstance = new Singleton(); 这段代码其实是分为三步执行：</p><ul><li>为 uniqueInstance 分配内存空间</li><li>初始化 uniqueInstance</li><li>将 uniqueInstance 指向分配的内存地址</li></ul><p>但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1-&gt;3-&gt;2。指令重排在单线程环境下不会出先问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 getUniqueInstance() 后发现 uniqueInstance 不为空，因此返回 uniqueInstance，但此时 uniqueInstance 还未被初始化。</p><p>使用 volatile 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java-并发进阶常见面试题总结&quot;&gt;&lt;a href=&quot;#Java-并发进阶常见面试题总结&quot; class=&quot;headerlink&quot; title=&quot;Java 并发进阶常见面试题总结&quot;&gt;&lt;/a&gt;Java 并发进阶常见面试题总结&lt;/h1&gt;&lt;h2 id=&quot;synchroni
      
    
    </summary>
    
      <category term="Java" scheme="https://wxzhongwang.github.io/categories/Java/"/>
    
    
      <category term="多线程" scheme="https://wxzhongwang.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Greenplum 从入门到放弃 四</title>
    <link href="https://wxzhongwang.github.io/2019/02/04/Greenplum%20%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
    <id>https://wxzhongwang.github.io/2019/02/04/Greenplum 从入门到放弃（四）/</id>
    <published>2019-02-04T02:10:00.000Z</published>
    <updated>2019-06-27T11:04:58.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Greenplum-从入门到放弃（四）"><a href="#Greenplum-从入门到放弃（四）" class="headerlink" title="Greenplum 从入门到放弃（四）"></a>Greenplum 从入门到放弃（四）</h1><h2 id="PostgreSQL与Greenplum的关系"><a href="#PostgreSQL与Greenplum的关系" class="headerlink" title="PostgreSQL与Greenplum的关系"></a>PostgreSQL与Greenplum的关系</h2><h3 id="PostgreSQL"><a href="#PostgreSQL" class="headerlink" title="PostgreSQL"></a>PostgreSQL</h3><p>PostgreSQL是一种非常先进的对象–关系型数据库管理系统（ORDBMS），是目前功能最强大，特性最丰富和技术最先进的自由软件数据库系统之一，其某些特性甚至连商业数据库都不具备。</p><p>PostgreSQL的特点可以说是数不胜数，称其为最先进的开<br>源软件数据库当之无愧，支持绝大部分的主流数据库特性，主<br>要体现在如下几方面：</p><ol><li>函数/存储过程</li></ol><p>PostgreSQL对非常丰富的过程类语言提供支持，可以编写自定义函数/存储过程</p><ul><li>内置的plpgsql，一种类似Oracle的PLsql的语言</li><li>支持的脚本语言有：PL/Lua、PL/LOLCODE、PL/Perl、PL/HP、PL/Python、PL/Ruby、PL/sh、PL/Tcl和PL/Scheme。、</li><li>编译语言有C、C++和JAVA。</li><li>·统计语言PL/R</li></ul><ol start="2"><li>索引</li></ol><p>PostgreSQL支持用户定义的索引访问方法，并且内置了Btree、哈希和GiST索引。PostgreSQL中的索引有下面几个特点：</p><ul><li>可以从后向前扫描</li><li>可以创建表达式索引</li><li>部分索引</li></ul><ol start="3"><li>触发器</li></ol><p>触发器是由SQL查询的动作触发的事件。比如，一个INSERT查询可能激活一个检查输入值是否有效的触发器。大多数触发器都只对INSERT或者UPDATE查询有效。PostgreSQL完全支持触发器，可以附着在表上，但是不能在视图上。不过视图可以有规则。多个触发器是按照字母顺序触发的。我们还可以用其他过程语言书写触发器函数，不仅仅PL/PgSQL。</p><ol start="4"><li>并发管理（MVCC）</li></ol><p>PostgreSQL的并发管理使用的是一种叫做“MVCC”（多版本并发机制）的机制，这种机制实际上就是现在在众多所谓的编程语言中极其火爆的“Lock Free”，其本质是通过类似科幻世界的时空穿梭的原理，给予每个用户一个自己的“时空”<br>，然后通过原子的“时空”控制来控制时间基线，并以此控制并发更改的可见区域，从而实现近乎无锁的并发，而同时还能在很大程度上保证数据库的ACID特性。</p><ol start="5"><li>规则（RULE）</li></ol><p>规则允许我们对由一个查询生成的查询树进行改写。</p><ol start="6"><li>数据类型</li></ol><p>PostgreSQL支持非常广泛的数据类型，包括：</p><ul><li>任意精度的数值类型；</li><li>无限长度的文本类型；</li><li>几何原语；</li><li>IPv4和IPv6类型；</li><li>CIDR块和MAC地址；</li><li>数组。</li></ul><p>用户还可以创建自己的类型，并且可以利用GiST框架把这些类型做成完全可索引的，比如来自PostGIS的地理信息系统（GIS）的数据类型。</p><ol start="7"><li>用户定义对象</li></ol><p>因为PostgreSQL使用一种基于系统表的可扩展的结构设计，所以PostgreSQL内部的几乎所有对象都可以由用户定义，这些对象包括：</p><ul><li>索引；</li><li>操作符（内部操作符可以被覆盖）；</li><li>聚集函数；</li><li>域；</li><li>类型转换；</li><li>编码转换。</li></ul><ol start="8"><li>继承</li></ol><p>PostgreSQL的表是可以相互继承的。一个表可以有父表，<br>父表的结构变化会导致子表的结构变化，而对子表的插入和数<br>据更新等也会反映到父表中。</p><ol start="9"><li>其他特性与扩展</li></ol><ul><li>二进制和文本大对象存储；</li><li>在线备份；</li><li>TOAST（The Oversized-Attribute Storage Technique）用于透明地在独立的地方保存大的数据库属性，当数据超过一定大小的时候，会自动进行压缩以节省空间；</li><li>正则表达式。</li></ul><p>此外PostgreSQL还有大量的附加模块和扩展版本，比如，多种不同的主从/主主复制方案:</p><ul><li>Slony-I；</li><li>pgcluster；</li><li>Mammoth replicator；</li><li>Bucardo。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Greenplum-从入门到放弃（四）&quot;&gt;&lt;a href=&quot;#Greenplum-从入门到放弃（四）&quot; class=&quot;headerlink&quot; title=&quot;Greenplum 从入门到放弃（四）&quot;&gt;&lt;/a&gt;Greenplum 从入门到放弃（四）&lt;/h1&gt;&lt;h2 i
      
    
    </summary>
    
      <category term="Greenplum" scheme="https://wxzhongwang.github.io/categories/Greenplum/"/>
    
    
      <category term="Greenplum" scheme="https://wxzhongwang.github.io/tags/Greenplum/"/>
    
  </entry>
  
  <entry>
    <title>Greenplum 从入门到放弃 三</title>
    <link href="https://wxzhongwang.github.io/2019/02/03/Greenplum%20%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>https://wxzhongwang.github.io/2019/02/03/Greenplum 从入门到放弃（三）/</id>
    <published>2019-02-03T02:10:00.000Z</published>
    <updated>2019-08-07T15:12:02.270Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Greenplum-从入门到放弃（三）"><a href="#Greenplum-从入门到放弃（三）" class="headerlink" title="Greenplum 从入门到放弃（三）"></a>Greenplum 从入门到放弃（三）</h1><h2 id="master-和-segment关系"><a href="#master-和-segment关系" class="headerlink" title="master 和 segment关系"></a>master 和 segment关系</h2><p>Master和Segment其实都是一个单独的PostgreSQL数据库。<br>每一个都有自己单独的一套元数据字典，在这里，Master节点<br>一般也叫主节点，Segment也叫做数据节点。<br>Segment节点与Master节点的通信，通过千兆（或万兆）<br>网卡组成的内部连接（InterConnect），在同一台数据节点机<br>器上可以放多个Segment，不同的Segment节点会被赋予不同的<br>端口，同时，Segment之间也不断地进行着交互。为了实现高<br>可用，每个Segment都有对应的备节点（Mirror Segment），分<br>别存在于不同的机器上。</p><blockquote><p>Client一般只能与Master节点进行交互，Client将SQL发给Master，然后Master对SQL进行分析后，再将其分配给所有的Segment进行操作，并且将汇总结果返回给客户端。</p></blockquote><h2 id="数据库存储"><a href="#数据库存储" class="headerlink" title="数据库存储"></a>数据库存储</h2><p>对于数据库来说，在性能上磁盘IO很容易成为瓶颈，由于数据库的特性，每一个SQL基本都是对全表数据进行分析，每次处理的数据量非常大，数据基本上都是没有缓存的（数据字典除外），极度消耗IO资源（全表扫描主要都是顺序IO），所以Greenplum对存储的要求比较高。在文件系统的选择上，在Linux下建议使用XFS，在Solaris下建议使用ZFS，对于Raid根据需求选择硬Raid或软Raid，如果需要更大的空间，建议使用Raid5，如果对性能有更高的要求，可以选择Raid 1+0。</p><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><p>在确定机器配置的时候，要保证所有机器的网络都是通的，并且每台机器的防火墙都是关闭的，避免存在网络不通的问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Greenplum-从入门到放弃（三）&quot;&gt;&lt;a href=&quot;#Greenplum-从入门到放弃（三）&quot; class=&quot;headerlink&quot; title=&quot;Greenplum 从入门到放弃（三）&quot;&gt;&lt;/a&gt;Greenplum 从入门到放弃（三）&lt;/h1&gt;&lt;h2 i
      
    
    </summary>
    
      <category term="Greenplum" scheme="https://wxzhongwang.github.io/categories/Greenplum/"/>
    
    
      <category term="Greenplum" scheme="https://wxzhongwang.github.io/tags/Greenplum/"/>
    
  </entry>
  
  <entry>
    <title>Greenplum 从入门到放弃 二</title>
    <link href="https://wxzhongwang.github.io/2019/02/02/Greenplum%20%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>https://wxzhongwang.github.io/2019/02/02/Greenplum 从入门到放弃（二）/</id>
    <published>2019-02-02T02:10:00.000Z</published>
    <updated>2019-08-07T15:11:53.239Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Greenplum-从入门到放弃（二）"><a href="#Greenplum-从入门到放弃（二）" class="headerlink" title="Greenplum 从入门到放弃（二）"></a>Greenplum 从入门到放弃（二）</h1><h2 id="OLTP与OLAP"><a href="#OLTP与OLAP" class="headerlink" title="OLTP与OLAP"></a>OLTP与OLAP</h2><p>数据库系统一般分为两种类型，一种是面向前台应用的，应用比较简单，但是重吞吐和高并发的OLTP类型；一种是重计算的，对大数据集进行统计分析的OLAP类型。Greenplum属于后者。</p><p>OLTP（On-Line Transaction<br>Processing，联机事务处理）系统也称为生产系统，它是事件驱动的、面向应用的，比如电<br>子商务网站的交易系统就是一个典型的OLTP系统。OLTP的基本特点是：</p><ul><li>数据在系统中产生</li><li>基于交易的处理系统（Transaction-Based）</li><li>每次交易牵涉的数据量很小</li><li>对响应时间要求非常高</li><li>用户数量非常庞大，主要是操作人员</li><li>数据库的各种操作主要基于索引进行</li></ul><p>OLAP（On-Line Analytical Processing，联机分析处理）是基于数据仓库的信息分析处理过程，是数据仓库的用户接口部分。OLAP系统是跨部门的、面向主题的，其基本特点是：</p><ul><li>本身不产生数据，其基础数据来源于生产系统中的操作数据（OperationalData）</li><li>基于查询的分析系统</li><li>复杂查询经常使用多表联结、全表扫描等，牵涉的数据量往往十分庞大</li><li>响应时间与具体查询有很大关系</li><li>用户数量相对较小，其用户主要是业务人员与管理人员</li><li>由于业务问题不固定，数据库的各种操作不能完全基于索引进行</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Greenplum-从入门到放弃（二）&quot;&gt;&lt;a href=&quot;#Greenplum-从入门到放弃（二）&quot; class=&quot;headerlink&quot; title=&quot;Greenplum 从入门到放弃（二）&quot;&gt;&lt;/a&gt;Greenplum 从入门到放弃（二）&lt;/h1&gt;&lt;h2 i
      
    
    </summary>
    
      <category term="Greenplum" scheme="https://wxzhongwang.github.io/categories/Greenplum/"/>
    
    
      <category term="Greenplum" scheme="https://wxzhongwang.github.io/tags/Greenplum/"/>
    
  </entry>
  
  <entry>
    <title>Greenplum 从入门到放弃 一</title>
    <link href="https://wxzhongwang.github.io/2019/02/01/Greenplum%20%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://wxzhongwang.github.io/2019/02/01/Greenplum 从入门到放弃（一）/</id>
    <published>2019-02-01T02:10:00.000Z</published>
    <updated>2019-08-07T15:11:58.238Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Greenplum-从入门到放弃（一）"><a href="#Greenplum-从入门到放弃（一）" class="headerlink" title="Greenplum 从入门到放弃（一）"></a>Greenplum 从入门到放弃（一）</h1><ul><li><p>Greenplum的性能在数据量为TB级别时表现非常优秀，单机性能相比Hadoop要快好几倍</p></li><li><p>Greenplum是基于PostgreSQL的一个完善的数据库，在功能和语法上都要比Hadoop上的SQL引擎Hive好用很多，对于普通用户来说更加容易上手。</p></li><li><p>Greenplum有着完善的工具，相比Hive，整个体系都比较完善，不需要像Hive一样花太多的时间和精力进行改造，非常适合作为一些大型的数据仓库解决方案。</p></li><li><p>Greenplum能够方便地与Hadoop进行结合，可直接把数据写在Hadoop上，还可以直接在数据库上写MapReduce任务，并且配置简单。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Greenplum-从入门到放弃（一）&quot;&gt;&lt;a href=&quot;#Greenplum-从入门到放弃（一）&quot; class=&quot;headerlink&quot; title=&quot;Greenplum 从入门到放弃（一）&quot;&gt;&lt;/a&gt;Greenplum 从入门到放弃（一）&lt;/h1&gt;&lt;ul&gt;

      
    
    </summary>
    
      <category term="Greenplum" scheme="https://wxzhongwang.github.io/categories/Greenplum/"/>
    
    
      <category term="Greenplum" scheme="https://wxzhongwang.github.io/tags/Greenplum/"/>
    
  </entry>
  
</feed>
