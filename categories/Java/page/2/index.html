<!DOCTYPE html>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="UTF-8">

    

    

    <title>Category: Java | 我喜欢你喜欢我的歌</title>
    <meta name="author" content="Dick Zhong">
    <meta name="version" content="1.0.0">
    <meta name="keywords" content>
    <meta name="description" content>
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">

    
    <link rel="alternate" href="/atom.xml" title="我喜欢你喜欢我的歌" type="application/atom+xml">
    
    
    <link rel="icon" href="/images/favicon.ico">
    

    <link rel="stylesheet" href="/css/style.css">
</head>
<body>

    <main class="app">
        <header class="header clearfix">
    <div id="nav" class="nav">
    <div class="nav-mobile">
        <button id="open-panel" class="open-panel nav-mobile-item"><i class="icon-documents"></i></button>
        <h1 class="nav-mobile-title nav-mobile-item">我喜欢你喜欢我的歌</h1>
        <button id="open-menus" class="open-panel nav-mobile-item"><i class="icon-library"></i></button>
    </div>

    <nav id="nav-inner" class="nav-inner">
        
            <a class="nav-item" href="/">
                <span class="nav-text">首页</span>
            </a>
        
            <a class="nav-item active" href="/categories/">
                <span class="nav-text">分类</span>
            </a>
        
            <a class="nav-item" href="/tags">
                <span class="nav-text">标签</span>
            </a>
        
            <a class="nav-item" href="/archives">
                <span class="nav-text">归档</span>
            </a>
        
            <a class="nav-item" href="/atom.xml">
                <span class="nav-text">订阅</span>
            </a>
        
            <a class="nav-item" href="/about">
                <span class="nav-text">关于</span>
            </a>
        
    </nav>
</div>

    <aside id="aside" class="aside">
    <div id="aside-mask" class="aside-mask"></div>
    <div id="aside-inner" class="aside-inner">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit"><i class="icon-search-stroke"></i></button><input type="hidden" name="sitesearch" value="https://wxzhongwang.github.io"></form>

        
        

        
        <div class="author-meta">
            
            <div class="author-avatar">
                <a href="/">
                    <img src="/images/27359059.jpg" title="咸鱼有点咸">
                </a>
            </div>
            
            <div class="author-name">咸鱼有点咸</div>
            <div class="author-work">Developer</div>
            <div class="author-location">
                <i class="icon-location vm"></i>
                <span class="vm">Hangzhou, China</span>
            </div>
            
            <div class="author-thread-wrap">
                <div class="author-threads clearfix">
                    
                        <a class="thread-item" href="https://github.com/wxzhongwang" target="_blank" rel="noopener">
                            <!-- Generated by IcoMoon.io -->
<svg viewbox="0 0 1024 1024" width="38" height="38" fill="currentColor">
<path d="M512 32.12c-265.004 0-479.88 220.23-479.88 492.090 0 217.446 137.536 401.684 328.202 466.81 23.994 4.498 32.778-10.712 32.778-23.78 0-11.782-0.428-42.632-0.642-83.764-133.466 29.778-161.744-65.984-161.744-65.984-21.852-56.772-53.344-71.982-53.344-71.982-43.49-30.636 3.214-29.992 3.214-29.992 48.202 3.428 73.482 50.772 73.482 50.772 42.846 75.196 112.258 53.558 139.68 40.918 4.284-31.706 16.71-53.558 30.42-65.77-106.474-12.426-218.516-54.63-218.516-243.152 0-53.772 18.638-97.69 49.274-131.966-4.928-12.426-21.424-62.556 4.714-130.252 0 0 40.276-13.282 131.966 50.344 38.348-10.926 79.266-16.282 120.184-16.496 40.704 0.214 81.836 5.57 120.184 16.496 91.692-63.626 131.752-50.344 131.752-50.344 26.136 67.698 9.64 117.828 4.714 130.252 30.636 34.492 49.274 78.408 49.274 131.966 0 188.952-112.258 230.514-219.16 242.724 17.138 15.21 32.564 45.202 32.564 91.048 0 65.77-0.642 118.898-0.642 134.966 0 13.068 8.57 28.492 32.992 23.566 191.094-64.912 328.418-249.152 328.418-466.382 0-271.86-214.874-492.090-479.88-492.090z"/>
</svg>

                        </a>
                    
                        <a class="thread-item" href="https://weibo.com/u/6558527999" target="_blank" rel="noopener">
                            <!-- Generated by IcoMoon.io -->
<svg viewbox="0 0 1024 1024" width="38" height="38" fill="currentColor">
<path d="M21.332 512c0-270.988 219.68-490.666 490.668-490.666s490.666 219.68 490.666 490.666c0 270.988-219.678 490.666-490.666 490.666s-490.666-219.678-490.666-490.666zM960 512c0-247.424-200.576-448-448-448s-448 200.576-448 448c0 247.424 200.576 448 448 448s448-200.576 448-448zM768 597.332c47.128 0 85.332-38.206 85.332-85.332s-38.206-85.332-85.332-85.332c-47.128 0-85.332 38.204-85.332 85.332s38.206 85.332 85.332 85.332zM512 597.332c47.128 0 85.332-38.206 85.332-85.332s-38.206-85.332-85.332-85.332c-47.128 0-85.332 38.204-85.332 85.332s38.204 85.332 85.332 85.332zM255.998 597.332c47.128 0 85.332-38.206 85.332-85.332s-38.204-85.332-85.332-85.332c-47.128 0-85.332 38.204-85.332 85.332s38.204 85.332 85.332 85.332z"/>
</svg>

                        </a>
                    
                        <a class="thread-item" href="https://twitter.com/wxzhongwang" target="_blank" rel="noopener">
                            <!-- Generated by IcoMoon.io -->
<svg viewbox="0 0 1024 1024" width="38" height="38" fill="currentColor">
<path d="M512.029 31.011c-263.32 0-476.784 213.502-476.784 476.784 0 263.32 213.464 476.743 476.784 476.743s476.743-213.424 476.743-476.743c0-263.282-213.444-476.784-476.743-476.784zM752.193 411.663c0.251 5.151 0.349 10.319 0.349 15.548 0 158.786-120.856 341.85-341.85 341.85-67.844 0-131.021-19.884-184.188-53.961 9.41 1.104 18.955 1.665 28.656 1.665 56.305 0 108.115-19.208 149.221-51.425-52.567-0.987-96.925-35.741-112.22-83.468 7.32 1.433 14.85 2.149 22.595 2.149 10.959 0 21.569-1.433 31.656-4.201-54.987-11.035-96.402-59.634-96.402-117.796 0-0.524 0-1.025 0.020-1.549 16.186 9.003 34.716 14.404 54.427 15.044-32.258-21.587-53.458-58.317-53.458-100.023 0-22.015 5.925-42.673 16.264-60.408 59.266 72.683 147.807 120.527 247.676 125.521-2.053-8.77-3.118-17.968-3.118-27.378 0-66.333 53.787-120.14 120.158-120.14 34.561 0 65.771 14.599 87.69 37.93 27.378-5.363 53.091-15.393 76.305-29.16-9.003 28.074-28.036 51.618-52.858 66.47 24.338-2.903 47.495-9.37 69.024-18.917-16.070 24.144-36.459 45.306-59.945 62.248z"/>
</svg>

                        </a>
                    
                </div>
            </div>
            
        </div>
        
    </div>
</aside>

</header>

        <div id="content" class="content">
    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2018/12/02/GC参数/">线上排查基本操作</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="https://wxzhongwang.github.io/categories/Java/page/2/index.html">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2018-12-02T04:30:00.000Z" itemprop="datePublished">2018-12-02</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/Java/">Java</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h1 id="GC-参数"><a href="#GC-参数" class="headerlink" title="GC 参数"></a>GC 参数</h1><ol>
<li>-Xms2048m                      初始堆大小</li>
<li>-Xmx2048m                        最大堆大小</li>
<li>-Xss:1024k                  设置每个线程堆栈大小，设置每个线程的堆栈大小。<br>JDK5.0以后每个线程堆栈大小为1M，以前每个线程堆栈大小为256K。<br>更具应用的线程所需内存大小进行调整。在相同物理内存下，减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右。</li>
<li>-XX:NewSize=n                  设置年轻代大小</li>
<li>-XX:NewRatio=2                 设置年轻代和年老代的比值。</li>
<li>-XX:SurvivorRatio=8         年轻代中Eden区与两个Survivor区的比值Eden:S1:S2 = 8:1:1  Eden:Survivor = 8 : 2</li>
<li>-XX:MaxPermSize=64m         设置持久代大小,持久代一般固定大小为64m</li>
<li>-XX:MaxMetaspaceSize=512m   元空间大小</li>
<li>-XX:MetaspaceSize=512m        最大元空间大小</li>
</ol>
<p>GC:</p>
<ol>
<li>-XX:+PrintGC                      打印GC</li>
<li>-XX:+PrintGCDetails               打印GC，格式不一样，详细</li>
<li>-XX:+PrintGCTimeStamps            PrintGCTimeStamps可与上面两个混合使用</li>
<li>-XX:+PrintHeapAtGC                打印GC前后的详细堆栈信息</li>
<li>-Xloggc:D:/temp/gclog/idea.gc.log 与上面几个配合使用，把相关日志信息记录到文件以便分析</li>
</ol>
<p>垃圾收集器：</p>
<ol>
<li>-XX:+UseSerialGC:设置串行收集器</li>
<li>-XX:+UseParallelGC:设置并行收集器</li>
<li>-XX:+UseParalledlOldGC:设置并行年老代收集器</li>
<li>-XX:+UseConcMarkSweepGC:设置并发收集器</li>
<li>-XX:InitialBootClassLoaderMetaspaceSize=64M</li>
<li>-XX:MaxTenuringThreshold=6        设置垃圾最大年龄，如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代。对于年老代比较多的应用，可以提高效率。如果将此值设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象再年轻代的存活时间，增加在年轻代即被回收的概论。</li>
<li>-XX:+UseConcMarkSweepGC</li>
<li><p>-XX:CMSFullGCsBeforeCompaction=5  使用并发收集器时，开启对年老代的压缩。由于并发收集器不对内存空间进行压缩、整理，所以运行一段时间以后会产生“碎片”，使得运行效率降低。此值设置运行多少次GC以后对内存空间进行压缩、整理。</p>
</li>
<li><p>-XX:+CMSParallelRemarkEnabled</p>
</li>
<li><p>-XX:+CMSClassUnloadingEnabled</p>
</li>
<li><p>-XX:+DisableExplicitGC</p>
</li>
<li>-XX:+ExplicitGCInvokesConcurrentAndUnloadsClasses</li>
<li>-XX:ReservedCodeCacheSize=240m</li>
<li>-XX:SoftRefLRUPolicyMSPerMB=50<br>-ea<br>-Dsun.io.useCanonCaches=false<br>-Djava.net.preferIPv4Stack=true<br>-XX:+HeapDumpOnOutOfMemoryError<br>-XX:-OmitStackTraceInFastThrow</li>
</ol>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2018/12/02/Java锁膨胀/">Java锁膨胀</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="https://wxzhongwang.github.io/categories/Java/page/2/index.html">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2018-12-02T04:30:00.000Z" itemprop="datePublished">2018-12-02</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/Java/">Java</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h1 id="Java锁膨胀"><a href="#Java锁膨胀" class="headerlink" title="Java锁膨胀"></a>Java锁膨胀</h1><blockquote>
<p>偏所锁，轻量级锁都是乐观锁，重量级锁是悲观锁。</p>
</blockquote>
<p>一个对象刚开始实例化的时候，没有任何线程来访问它的时候。它是可偏向的，意味着，它现在认为只可能有一个线程来访问它，所以当第一个线程来访问它的时候，它会偏向这个线程，此时，对象持有==偏向锁==。偏向第一个线程，这个线程在修改对象头成为偏向锁的时候使用CAS操作，并将对象头中的ThreadID改成自己的ID，之后再次访问这个对象时，只需要对比ID，不需要再使用CAS在进行操作。</p>
<p>一旦有第二个线程访问这个对象，因为偏向锁不会主动释放，所以第二个线程可以看到对象时偏向状态，这时表明在这个对象上已经存在竞争了，检查原来持有该对象锁的线程是否依然存活，如果挂了，则可以将对象变为==无锁状态==，然后重新偏向新的线程，如果原来的线程依然存活，则马上执行那个线程的操作栈，检查该对象的使用情况，如果仍然需要持有偏向锁，则偏向锁升级为==轻量级锁==，（偏向锁就是这个时候升级为轻量级锁的）。如果不存在使用了，则可以将对象回复成无锁状态，然后重新偏向。轻量级锁认为竞争存在，但是竞争的程度很轻，一般两个线程对于同一个锁的操作都会错开，或者说稍微等待一下（自旋），另一个线程就会释放锁。但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁膨胀为重量级锁，重量级锁使除了拥有锁的线程以外的线程都阻塞，防止CPU空转。</p>
<p><img src="https://oscimg.oschina.net/oscnet/2bcc8161c52eb100d2c7c4c96c70d3c5823.jpg" alt="锁膨胀"></p>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2018/12/02/个人面试遇到的一些问题/">线上排查基本操作</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="https://wxzhongwang.github.io/categories/Java/page/2/index.html">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2018-12-02T04:30:00.000Z" itemprop="datePublished">2018-12-02</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/JVM/">JVM</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h1 id="1-Dubbo-Zk-如何实现动态选择负载均衡策略"><a href="#1-Dubbo-Zk-如何实现动态选择负载均衡策略" class="headerlink" title="1. Dubbo + Zk 如何实现动态选择负载均衡策略"></a>1. Dubbo + Zk 如何实现动态选择负载均衡策略</h1><h1 id="2-Nginx-能实现哪些功能？-如何修改请求头？"><a href="#2-Nginx-能实现哪些功能？-如何修改请求头？" class="headerlink" title="2. Nginx 能实现哪些功能？ 如何修改请求头？"></a>2. Nginx 能实现哪些功能？ 如何修改请求头？</h1><pre><code>静态代理（资源托管）
反向代理（请求转发）

方式一：proxy_set_header
proxy_set_header   iden    &quot;student&quot;;
proxy_set_header   age     &quot;21&quot;;

方式二：set 方式
set $iden &quot;student&quot;;
set $age &quot;21&quot;;
</code></pre><h1 id="3-Java-什么时候会发生锁升级为重量级锁？"><a href="#3-Java-什么时候会发生锁升级为重量级锁？" class="headerlink" title="3. Java 什么时候会发生锁升级为重量级锁？"></a>3. Java 什么时候会发生锁升级为重量级锁？</h1><pre><code>（锁膨胀）
</code></pre><h1 id="4-HashMap并发过程中出现CPU崩溃？什么原因？"><a href="#4-HashMap并发过程中出现CPU崩溃？什么原因？" class="headerlink" title="4. HashMap并发过程中出现CPU崩溃？什么原因？"></a>4. HashMap并发过程中出现CPU崩溃？什么原因？</h1><pre><code>https://blog.csdn.net/c929833623lvcha/article/details/8924414?utm_source=jiancool
</code></pre><h1 id="5-ConcurrentHashMap-锁具体实现原理？"><a href="#5-ConcurrentHashMap-锁具体实现原理？" class="headerlink" title="5. ConcurrentHashMap 锁具体实现原理？"></a>5. ConcurrentHashMap 锁具体实现原理？</h1><h1 id="6-SpringCloud-熔断机制，客户端如何捕获异常？"><a href="#6-SpringCloud-熔断机制，客户端如何捕获异常？" class="headerlink" title="6. SpringCloud 熔断机制，客户端如何捕获异常？"></a>6. SpringCloud 熔断机制，客户端如何捕获异常？</h1><h1 id="7-Zookeeper的选举机制？一定是过半选举么？"><a href="#7-Zookeeper的选举机制？一定是过半选举么？" class="headerlink" title="7. Zookeeper的选举机制？一定是过半选举么？"></a>7. Zookeeper的选举机制？一定是过半选举么？</h1><h1 id="8-Redis-实现分布式锁？"><a href="#8-Redis-实现分布式锁？" class="headerlink" title="8. Redis 实现分布式锁？"></a>8. Redis 实现分布式锁？</h1><pre><code>SETNX 原理
</code></pre><h1 id="9-MySQL-索引在什么场景下使用会发生失效？原因是什么？"><a href="#9-MySQL-索引在什么场景下使用会发生失效？原因是什么？" class="headerlink" title="9. MySQL 索引在什么场景下使用会发生失效？原因是什么？"></a>9. MySQL 索引在什么场景下使用会发生失效？原因是什么？</h1><h1 id="10-MySQL-MVCC"><a href="#10-MySQL-MVCC" class="headerlink" title="10. MySQL MVCC"></a>10. MySQL MVCC</h1><h1 id="11-MySQL-一张表-没有主键，但是有一列聚集索引，底层是怎么样？"><a href="#11-MySQL-一张表-没有主键，但是有一列聚集索引，底层是怎么样？" class="headerlink" title="11. MySQL 一张表 没有主键，但是有一列聚集索引，底层是怎么样？"></a>11. MySQL 一张表 没有主键，但是有一列聚集索引，底层是怎么样？</h1><pre><code>延伸: 如果是非InnoDB存储引擎，是怎么实现的。
</code></pre>
        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2018/12/02/用户UID生成策略/">用户UID生成策略</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="https://wxzhongwang.github.io/categories/Java/page/2/index.html">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2018-12-02T04:30:00.000Z" itemprop="datePublished">2018-12-02</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/Java/">Java</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h1 id="用户UID生成策略"><a href="#用户UID生成策略" class="headerlink" title="用户UID生成策略"></a>用户UID生成策略</h1><p><a href="https://segmentfault.com/a/1190000023588832" target="_blank" rel="noopener">用户UID生成策略</a></p>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">https:</span><span class="comment">//segmentfault.com/a/1190000023588832</span></span><br></pre></td></tr></table></figure>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2018/12/02/TPS和QPS到底搞明白了么/">TPS和QPS到底搞明白了么</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="https://wxzhongwang.github.io/categories/Java/page/2/index.html">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2018-12-02T04:30:00.000Z" itemprop="datePublished">2018-12-02</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/Java/">Java</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h1 id="TPS和QPS到底搞明白了么"><a href="#TPS和QPS到底搞明白了么" class="headerlink" title="TPS和QPS到底搞明白了么"></a>TPS和QPS到底搞明白了么</h1><h2 id="TPS"><a href="#TPS" class="headerlink" title="TPS"></a>TPS</h2><p>TPS：Transactions Per Second，意思是每秒事务数，具体事务的定义，都是人为的，可以一个接口、多个接口、一个业务流程等等。一个事务是指事务内第一个请求发送到接收到最后一个请求的响应的过程，以此来计算使用的时间和完成的事务个数。</p>
<p>以单接口定义为事务为例，每个事务包括了如下3个过程：</p>
<p>　　a.向服务器发请求</p>
<p>　　b.服务器自己的内部处理（包含应用服务器、数据库服务器等）</p>
<p>　　c.服务器返回结果给客户端</p>
<p>　　如果每秒能够完成N次这三个过程，tps就是N；</p>
<p>如果多个接口定义为一个事务，那么，会重复执行abc，完成一次这几个请求，算做一个tps。</p>
<h2 id="QPS"><a href="#QPS" class="headerlink" title="QPS"></a>QPS</h2><p>QPS：Queries Per Second，意思是每秒查询率，是一台服务器每秒能够响应的查询次数（数据库中的每秒执行查询sql的次数），显然，这个不够全面，不能描述增删改，所以，不建议用qps来作为系统性能指标。</p>
<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>如果是对一个查询接口（单场景）压测，且这个接口内部不会再去请求其它接口，那么tps=qps，否则，tps≠qps</p>
<p>如果是容量场景，假设n个接口都是查询接口，且这个接口内部不会再去请求其它接口，qps=n*tps</p>
<p>jmeter聚合报告中，Throughput是用来衡量请求的吞吐量，也就是tps，tps=样本数/运行时间<br>如果没有定义事务，会把每个请求作为一个事务</p>
<p>QPS是Query Per Second，是数据库中的概念，每秒执行条数（查询），被引申到压测中来了，但是不包括插入、更新、删除操作，所以不建议用qps来描述系统整体的性能；</p>
<p>建议用tps，这个t，你可以随意的定义，可以是一个接口，也可以是一个业务流程等等。</p>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2018/12/02/tomcat最大线程数的设置/">tomcat最大线程数的设置</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="https://wxzhongwang.github.io/categories/Java/page/2/index.html">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2018-12-02T04:30:00.000Z" itemprop="datePublished">2018-12-02</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/Java/">Java</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h1 id="tomcat最大线程数的设置"><a href="#tomcat最大线程数的设置" class="headerlink" title="tomcat最大线程数的设置"></a>tomcat最大线程数的设置</h1><p>Tomcat的server.xml中连接器设置如下</p>
<h2 id="1-Tomcat配置"><a href="#1-Tomcat配置" class="headerlink" title="1.Tomcat配置"></a>1.Tomcat配置</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;Connector <span class="attribute">port</span>=<span class="string">"8080"</span>     </span><br><span class="line">   <span class="attribute">maxThreads</span>=<span class="string">"150"</span> <span class="attribute">minSpareThreads</span>=<span class="string">"25"</span> <span class="attribute">maxSpareThreads</span>=<span class="string">"75"</span>     </span><br><span class="line">   <span class="attribute">enableLookups</span>=<span class="string">"false"</span> <span class="attribute">redirectPort</span>=<span class="string">"8443"</span> <span class="attribute">acceptCount</span>=<span class="string">"100"</span>     </span><br><span class="line">   <span class="attribute">debug</span>=<span class="string">"0"</span> <span class="attribute">connectionTimeout</span>=<span class="string">"20000"</span>      </span><br><span class="line">   <span class="attribute">disableUploadTimeout</span>=<span class="string">"true"</span> /&gt;</span><br></pre></td></tr></table></figure>
<h2 id="2-如何加大tomcat连接数"><a href="#2-如何加大tomcat连接数" class="headerlink" title="2.如何加大tomcat连接数"></a>2.如何加大tomcat连接数</h2><p>在tomcat配置文件server.xml中的<connector>配置中，和连接数相关的参数有：</connector></p>
<ul>
<li>minProcessors：最小空闲连接线程数，用于提高系统处理性能，默认值为10</li>
<li>maxProcessors：最大连接线程数，即：并发处理的最大请求数，默认值为75</li>
<li>acceptCount：允许的最大连接数，应大于等于maxProcessors，默认值为100</li>
<li>enableLookups：是否反查域名，取值为：true或false。为了提高处理能力，应设置为false</li>
<li>connectionTimeout：网络连接超时，单位：毫秒。设置为0表示永不超时，这样设置有隐患的。通常可设置为30000毫秒。</li>
</ul>
<p>其中和最大连接数相关的参数为maxProcessors和acceptCount。如果要加大并发连接数，应同时加大这两个参数。<br>web server允许的最大连接数还受制于操作系统的内核参数设置，通常Windows是2000个左右，Linux是1000个左右。tomcat5中的配置示例：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;Connector <span class="attribute">port</span>=<span class="string">"8080"</span></span><br><span class="line">   <span class="attribute">maxThreads</span>=<span class="string">"150"</span> <span class="attribute">minSpareThreads</span>=<span class="string">"25"</span> <span class="attribute">maxSpareThreads</span>=<span class="string">"75"</span></span><br><span class="line">   <span class="attribute">enableLookups</span>=<span class="string">"false"</span> <span class="attribute">redirectPort</span>=<span class="string">"8443"</span> <span class="attribute">acceptCount</span>=<span class="string">"100"</span></span><br><span class="line">   <span class="attribute">debug</span>=<span class="string">"0"</span> <span class="attribute">connectionTimeout</span>=<span class="string">"20000"</span></span><br><span class="line">   <span class="attribute">disableUploadTimeout</span>=<span class="string">"true"</span> /&gt;</span><br></pre></td></tr></table></figure></p>
<p>对于其他端口的侦听配置，以此类推。</p>
<h2 id="3-tomcat中如何禁止列目录下的文件"><a href="#3-tomcat中如何禁止列目录下的文件" class="headerlink" title="3.tomcat中如何禁止列目录下的文件"></a>3.tomcat中如何禁止列目录下的文件</h2><p>在{tomcat_home}/conf/web.xml中，把listings参数设置成false即可，如下：</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;init-<span class="built_in">param</span>&gt;  </span><br><span class="line">    &lt;<span class="built_in">param</span>-name&gt;listings&lt;/<span class="built_in">param</span>-name&gt;  </span><br><span class="line">    &lt;<span class="built_in">param</span>-<span class="built_in">value</span>&gt;<span class="literal">false</span>&lt;/<span class="built_in">param</span>-<span class="built_in">value</span>&gt;  </span><br><span class="line">&lt;/init-<span class="built_in">param</span>&gt;</span><br></pre></td></tr></table></figure>
<h2 id="4-如何加大tomcat可以使用的内存"><a href="#4-如何加大tomcat可以使用的内存" class="headerlink" title="4.如何加大tomcat可以使用的内存"></a>4.如何加大tomcat可以使用的内存</h2><p>tomcat默认可以使用的内存为128MB，在较大型的应用项目中，这点内存是不够的，需要调大。<br>Unix下，在文件{tomcat_home}/bin/catalina.sh的前面，增加如下设置：<br>JAVA_OPTS=’-Xms【初始化内存大小】 -Xmx【可以使用的最大内存】’<br>需要把这个两个参数值调大。例如：<br>JAVA_OPTS=’-Xms256m -Xmx512m’<br>表示初始化内存为256MB，可以使用的最大内存为512MB</p>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2018/12/02/线上排查基本操作/">线上排查基本操作</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="https://wxzhongwang.github.io/categories/Java/page/2/index.html">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2018-12-02T04:30:00.000Z" itemprop="datePublished">2018-12-02</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/JVM/">JVM</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h1 id="线上排查基本操作"><a href="#线上排查基本操作" class="headerlink" title="线上排查基本操作"></a>线上排查基本操作</h1><h2 id="1-CPU-飚高"><a href="#1-CPU-飚高" class="headerlink" title="1. CPU 飚高"></a>1. CPU 飚高</h2><p>线上 CPU 飚高问题大家应该都遇到过，那么如何定位问题呢？</p>
<p>思路：首先找到 CPU 飚高的那个 Java 进程，因为你的服务器会有多个 JVM 进程。然后找到那个进程中的 “问题线程”，最后根据线程堆栈信息找到问题代码。最后对代码进行排查。</p>
<p>如何操作呢？</p>
<p>通过 top 命令找到 CPU 消耗最高的进程，并记住进程 ID。<br>再次通过 top -Hp [进程 ID] 找到 CPU 消耗最高的线程 ID，并记住线程 ID.<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top -<span class="symbol">Hp</span> [进程 <span class="symbol">ID</span>]  -- 找到 <span class="symbol">CPU</span> 消耗最高的线程 <span class="symbol">ID</span>，并记住线程 <span class="symbol">ID</span>.</span><br></pre></td></tr></table></figure></p>
<p>通过 JDK 提供的 jstack 工具 dump 线程堆栈信息到指定文件中。具体命令：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jstack -l [进程 ID] &gt;jstack.log。</span><br><span class="line"></span><br><span class="line">由于刚刚的线程 ID 是十进制的，而堆栈信息中的线程 ID 是<span class="number">16</span>进制的，因此我们需要将<span class="number">10</span>进制的转换成<span class="number">16</span>进制的，并用这个线程 ID 在堆栈中查找。使用 printf <span class="string">"%x<span class="subst">\n</span>"</span> [十进制数字] ，可以将<span class="number">10</span>进制转换成<span class="number">16</span>进制。</span><br></pre></td></tr></table></figure></p>
<p>通过刚刚转换的16进制数字从堆栈信息里找到对应的线程堆栈。就可以从该堆栈中看出端倪。<br>从经验来看，一般是某个业务死循环没有出口，这种情况可以根据业务进行修复。<br>还有 C2 编译器执行编译时也会抢占 CPU，什么是 C2编译器呢？<br>当 Java 某一段代码执行次数超过10000次（默认）后，<br>就会将该段代码从解释执行改为编译执行，也就是编译成机器码以提高速度。<br>而这个 C2编译器就是做这个的。如何解决呢？项目上线后，可以先通过压测工具进行预热，<br>这样，等用户真正访问的时候，C2编译器就不会干扰应用程序了。<br>如果是 GC 线程导致的，那么极有可能是 Full GC ，那么就要进行 GC 的优化。</p>
<h2 id="2-内存问题排查"><a href="#2-内存问题排查" class="headerlink" title="2. 内存问题排查"></a>2. 内存问题排查</h2><p>说完了 CPU 的问题排查，再说说内存的排查，通常，内存的问题就是 GC 的问题，因为 Java 的内存由 GC 管理。<br>有2种情况，一种是内存溢出了，一种是内存没有溢出，但 GC 不健康。</p>
<h2 id="内存溢出OOM"><a href="#内存溢出OOM" class="headerlink" title="内存溢出OOM"></a>内存溢出OOM</h2><p>内存溢出的情况可以通过加上 -XX:+HeapDumpOnOutOfMemoryError 参数，该参数作用是：在程序内存溢出时输出 dump 文件。</p>
<p>有了 dump 文件，就可以通过 dump 分析工具进行分析了，比如常用的MAT，Jprofile，jvisualvm 等工具都可以分析，这些工具都能够看出到底是哪里溢出，哪里创建了大量的对象等等信息。</p>
<h2 id="GC-的健康问题-第二种情况就比较复杂了"><a href="#GC-的健康问题-第二种情况就比较复杂了" class="headerlink" title="GC 的健康问题(第二种情况就比较复杂了)"></a>GC 的健康问题(第二种情况就比较复杂了)</h2><p>通常一个健康的 GC 是什么状态呢？</p>
<p>YGC 5秒一次左右，每次不超过50毫秒，FGC 最好没有，CMS GC 一天一次左右。</p>
<p>而 GC 的优化有2个维度:</p>
<blockquote>
<p>一是频率，二是时长。</p>
</blockquote>
<h3 id="YGC-年轻代GC"><a href="#YGC-年轻代GC" class="headerlink" title="YGC 年轻代GC"></a>YGC 年轻代GC</h3><p>首先看频率，如果 YGC 超过5秒一次，甚至更长，说明系统内存过大，应该缩小容量<br>如果频率很高，说明 Eden 区过小，可以将 Eden 区增大，但整个新生代的容量应该在堆的 30% - 40%之间，<br>eden，from 和 to 的比例应该在 8：1：1左右，这个比例可根据对象晋升的大小进行调整。</p>
<p>如果YGC时间过长呢？<br>YGC 有2个过程，一个是扫描，一个是复制，通常扫描速度很快，复制速度相比而言要慢一些，如果每次都有大量对象要复制，<br>就会将 STW 时间延长，还有一个情况就是 StringTable ，这个数据结构中存储着 String.intern 方法返回的常连池的引用，<br>YGC 每次都会扫描这个数据结构（HashTable），如果这个数据结构很大，且没有经过 FGC，那么也会拉长 STW 时长，<br>还有一种情况就是操作系统的虚拟内存，当 GC 时正巧操作系统正在交换内存，也会拉长 STW 时长。</p>
<h3 id="FGC"><a href="#FGC" class="headerlink" title="FGC"></a>FGC</h3><p>实际上，FGC 我们只能优化频率，无法优化时长，因为这个时长无法控制。如何优化频率呢？</p>
<p>首先，FGC 的原因有几个:<br>1.Old 区内存不够<br>2.元数据区内存不够<br>3.System.gc()<br>4.执行jmap 或者 jcmd，<br>5.是CMS Promotion failed 或者 concurrent mode failure，<br>6.JVM 基于悲观策略认为这次 YGC 后 Old 区无法容纳晋升的对象，因此取消 YGC，提前 FGC。</p>
<p>通常优化的点是 Old 区内存不够导致 FGC。<br>如果 FGC 后还有大量对象，说明 Old 区过小，应该扩大 Old 区。<br>如果 FGC 后效果很好，说明 Old 区存在了大量短命的对象，优化的点应该是让这些对象在新生代就被 YGC 掉，<br>通常的做法是增大新生代，如果有大而短命的对象，通过参数设置对象的大小，不要让这些对象进入 Old 区，还需要检查晋升年龄是否过小。<br>如果 YGC 后，有大量对象因为无法进入 Survivor 区从而提前晋升，这时应该增大 Survivor 区，但不宜太大。</p>
<p>上面说的都是优化的思路，我们也需要一些工具知道 GC 的状况。</p>
<p>JDK 提供了很多的工具，比如 jmap ，jcmd 等，oracle 官方推荐使用 jcmd 代替 jmap，因为 jcmd 确实能代替 jmap 很多功能。<br>jmap 可以打印对象的分布信息，可以 dump 文件，注意，jmap 和 jcmd dump 文件的时候会触发 FGC ，使用的时候注意场景。</p>
<p>还有一个比较常用的工具是 jstat，该工具可以查看GC 的详细信息，比如eden ，from，to，old 等区域的内存使用情况。<br>还有一个工具是 jinfo，该工具可以查看当前 jvm 使用了哪些参数，并且也可以在不停机的情况下修改参数。</p>
<p>包括我们上面说的一些分析 dump 文件的可视化工具，MAT，Jprofile，jvisualvm 等，这些工具可以分析 jmap dump 下来的文件，看看哪个对象使用的内存较多，通常是能够查出问题的。</p>
<p>还有很重要的一点就是，线上环境一定要带上 GC 日志！！！</p>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2018/10/01/JVM课程七/">JVM课程七</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="https://wxzhongwang.github.io/categories/Java/page/2/index.html">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2018-10-01T14:22:22.000Z" itemprop="datePublished">2018-10-01</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/JVM/">JVM</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h2 id="分代收集器"><a href="#分代收集器" class="headerlink" title="分代收集器"></a>分代收集器</h2><p>一起七个 3 + 3 + 1</p>
<p>在收集器使用的时候都是：新老搭配的。</p>
<p>新生代收集器：</p>
<ul>
<li>Serial</li>
<li>ParNew</li>
<li>Parallel Scavenge</li>
</ul>
<p>老年代收集器：</p>
<ul>
<li>CMS(Concurrent Mark Sweep)</li>
<li>Serial Old </li>
<li>Parallel Old</li>
</ul>
<p>新老通吃：<br>G1: Garbadge First</p>
<h2 id="新生代收集器"><a href="#新生代收集器" class="headerlink" title="新生代收集器"></a>新生代收集器</h2><h3 id="Serial-GC-串行"><a href="#Serial-GC-串行" class="headerlink" title="Serial GC(串行)"></a>Serial GC(串行)</h3><p>HotSpot运行在client模式下的默认新生代收集器。只用一个CPU/一个收集器线程去完成GC。<br>“Stop The World” -XX:+UseSerialGC</p>
<ol>
<li>启动回收</li>
<li>暂停其他所有工作线程。新生代回收采用<strong>复制</strong>算法。</li>
<li>暂停其他所有工作线程。老年代回收采用<strong>标记整理算法</strong>。单线程收集，但是简单高效。<br>在内存占用不大的应用中，效率很高。</li>
</ol>
<h3 id="ParNew-并行"><a href="#ParNew-并行" class="headerlink" title="ParNew(并行)"></a>ParNew(并行)</h3><p>其本质是Serial的多线程版本，目的是缩短垃圾收集的时间，也就是占用工作线程时间的问题。单CPU甚至不如Serial，但是在多核CPU配合多线程效果明显。多核CPU + 超线程技术。<br>若VM启用老年代使用CMS(concurrent mark sweep)时候，<br>参数： -XX:+UseConcMarkSweepGC<br>新生代次收集器默认为ParNew。<br>多核CPU时候一般配置为CPU核数。-XX:ParallelGCThreads=<n> 参数控制GC线程数。</n></p>
<ol>
<li>启动回收</li>
<li>暂停其他所有工作线程。新生代回收采用<strong>复制</strong>算法。 (GC线程多个同时工作，并行执行)</li>
<li>暂停其他所有工作线程。老年代回收采用<strong>标记整理算法</strong>。</li>
</ol>
<h3 id="Parallel-Scavenge"><a href="#Parallel-Scavenge" class="headerlink" title="Parallel Scavenge"></a>Parallel Scavenge</h3><p>并行多线程，复制算法。关注点与ParNew不同，关注的是系统吞吐量。</p>
<p>系统吞吐量 = 运行用户代码时间 /（运行用户代码时间 + 垃圾回收时间）</p>
<p>停顿时间越短就越适用于用户交互的程序。良好的响应速度提升用户体验。<br>而高吞吐则适用于后台计算而不需要太多交互的任务，可以最高效率的利用CPU时间，<br>尽快的完成程序的运算任务。</p>
<h2 id="老年代收集器"><a href="#老年代收集器" class="headerlink" title="老年代收集器"></a>老年代收集器</h2><h3 id="Serial-Old"><a href="#Serial-Old" class="headerlink" title="Serial Old"></a>Serial Old</h3><ol>
<li>启动回收</li>
<li>暂停其他所有工作线程。新生代回收采用复制算法。</li>
<li>暂停其他所有工作线程。老年代回收采用标记整理算法。单线程收集，但是简单高效。<br>在内存占用不大的应用中，效率很高。</li>
</ol>
<p>可以与任意的新生代收集器配置使用</p>
<h3 id="Parallel-Old"><a href="#Parallel-Old" class="headerlink" title="Parallel Old"></a>Parallel Old</h3><p>只能配合Parallel Scavenge收集器一起使用。</p>
<h3 id="CMS-并发"><a href="#CMS-并发" class="headerlink" title="CMS (并发)"></a>CMS (并发)</h3><p>Concurrent Mark Sweep,可以和用户线程同时工作。是一款并发收集器。<br>虽然有理论上表现更好的G1收集器，主流的仍然是CMS收集器。<br>能用于server模式下的JVM优化。能结合新生代的Serial 和 ParNew一起使用。</p>
<h2 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h2><p>Garbage-First。可以运用在新生代和老年代的直接分区收集。面向服务端的垃圾收集器。 –XX:+UseG1GC<br>将Java堆划分为多个相等的独立区域Region，保留新生代和老年代的概念。但是不再是物理隔离。</p>
<p>优化方式：<br>1.选择JVM版本<br>2.对于堆区大小的分配<br>3.垃圾回收的方式</p>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2018/09/20/JVM课程八/">JVM课程八</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="https://wxzhongwang.github.io/categories/Java/page/2/index.html">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2018-09-20T06:55:00.000Z" itemprop="datePublished">2018-09-20</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/JVM/">JVM</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h1 id="JVM性能监测工具"><a href="#JVM性能监测工具" class="headerlink" title="JVM性能监测工具"></a>JVM性能监测工具</h1><p><strong>jps</strong><br>      查询运行于jvm的线程jps -l</p>
<p><strong>jstat</strong><br>        查看HotSpot VM运行的信息<br>        jstat -gc pid 毫秒数 次数</p>
<pre><code>From Created
From Used
To Created 
To Used
Eden Created
Eden Used
Old Created
Old Used
Permanent Created
Permanent Used
Young GC 次收集器收集次数
Young GC Time 次收集器时间
Full GC  全收集次数
Full GC Time 全收集时间
GC Time 收集总时间
S0C S1C S0U S1U EC EU OC OU PC PU YGC YGCT FGC FGCT GCT
</code></pre><p><strong>jvisualvm</strong><br>        可视化工具<br>        jvisualvm</p>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2018/09/15/JVM课程六/">JVM课程六</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="https://wxzhongwang.github.io/categories/Java/page/2/index.html">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2018-09-15T15:12:00.000Z" itemprop="datePublished">2018-09-15</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/JVM/">JVM</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h1 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h1><p>Scavenge(次收集) 和 Full GC(全收集)区别</p>
<p>新生代GC (Scavenge GC): 发生在新生代的GC，因为新生代的Java对象大多是朝生夕死，所以Scavenge GC非常频繁。<br>回收速度快，当Eden内存空间不足时，会触发Scavenge GC。<br>一般情况下，当新对象生成时，并且在Eden中申请空间失败，就会触发Scavenge GC,对Eden区进行GC，清除非存活对象，<br>将尚存活的对象移动至Survivor区，然后整理两个Survivor区，这种方式的GC是对年轻代的Eden区进行，不会影响老年代。</p>
<p>老年代GC (Full GC/Major GC): Full GC是指发生在老年代的GC。出现了Full GC一般至少会伴随一次Minor GC。<br>老年代的对象大多是Minor GC过程中从新生代进入老年代。比如分配担保失败。Full GC的速度一般会比Minor GC慢十倍以上。<br>当老年代内存不足时或者显式调用System.gc()时候，会触发Full GC。</p>
<p>次收集：<br>当年轻代堆空间紧张会被触发，相对于全收集，收集间隔较短。</p>
<p>全收集：<br>当老年代或者持久代空间满了时候会触发全收集操作。可以使用System.gc()显式调用。<br>全收集一般会根据堆大小，需要的时间较长。不过全收集时间超过3s-5s,那就太长了。</p>
<p>新生代收集器：<br>Serial<br>ParNew<br>Parallel scavenge </p>
<p>老年代收集器：<br>CMS(Concurrent Mark Sweep)<br>Serial Old<br>Parallel Old </p>
<p>新老通吃：<br>G1: Garbadge First</p>

        
    </section>
</article>




<nav class="page-nav">
    <a class="extend prev" rel="prev" href="/categories/Java/">&laquo; 上一页</a><a class="page-number" href="/categories/Java/">1</a><span class="page-number current">2</span><a class="page-number" href="/categories/Java/page/3/">3</a><a class="page-number" href="/categories/Java/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/categories/Java/page/9/">9</a><a class="extend next" rel="next" href="/categories/Java/page/3/">下一页 &raquo;</a>
</nav>


</div>
        <footer class="footer">
    Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, Theme by <a href="https://github.com/sanonz/hexo-theme-concise" target="_blank">Concise</a>

    
    <script>
        var _hmt = _hmt || [];
        (function () {
            var hm = document.createElement("script");
            hm.src = "https://hm.baidu.com/hm.js?e4027971a230b210f4671f485b33846a";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();
    </script>
    
</footer>

    </main>

    <script type="text/javascript" src="https://cdn.bootcss.com/jquery/1.9.0/jquery.min.js"></script>
    <script type="text/javascript">
    $(function() {
        var nodes = {
            nav: $('#nav'),
            aside: $('#aside'),
            asideInner: $('#aside-inner'),
            navInner: $('#nav-inner')
        };

        var doing = false;
        nodes.asideInner.on('webkitAnimationEnd mozAnimationEnd oAnimationEnd oanimationend animationend', function() {
            if (nodes.aside.hasClass('mobile-open')) {
                nodes.aside.removeClass('mobile-open');
            } else {
                nodes.aside.removeClass('mobile-close panel-show');
            }
            doing = false;
        });
        $('#open-panel, #aside-mask').on('click', function() {
            if (doing) {
                return;
            }
            
            if (nodes.aside.hasClass('panel-show')) {
                nodes.aside.addClass('mobile-close');
            } else {
                nodes.aside.addClass('mobile-open panel-show');
            }
        });
        $('#open-menus').on('click', function() {
            nodes.navInner.slideToggle();
        });

        if (window.innerWidth <= 960) {
            setTimeout(function() {
                nodes.navInner.slideUp();
            }, 3000);
        }
    });
    </script>
    

</body>
</html>
