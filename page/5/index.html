<!DOCTYPE html>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="UTF-8">

    

    

    <title>我喜欢你喜欢我的歌</title>
    <meta name="author" content="Dick Zhong">
    <meta name="version" content="1.0.0">
    <meta name="keywords" content>
    <meta name="description" content>
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">

    
    <link rel="alternate" href="/atom.xml" title="我喜欢你喜欢我的歌" type="application/atom+xml">
    
    
    <link rel="icon" href="/images/favicon.ico">
    

    <link rel="stylesheet" href="/css/style.css">
</head>
<body>

    <main class="app">
        <header class="header clearfix">
    <div id="nav" class="nav">
    <div class="nav-mobile">
        <button id="open-panel" class="open-panel nav-mobile-item"><i class="icon-documents"></i></button>
        <h1 class="nav-mobile-title nav-mobile-item">我喜欢你喜欢我的歌</h1>
        <button id="open-menus" class="open-panel nav-mobile-item"><i class="icon-library"></i></button>
    </div>

    <nav id="nav-inner" class="nav-inner">
        
            <a class="nav-item active" href="/">
                <span class="nav-text">首页</span>
            </a>
        
            <a class="nav-item" href="/categories/">
                <span class="nav-text">分类</span>
            </a>
        
            <a class="nav-item" href="/tags">
                <span class="nav-text">标签</span>
            </a>
        
            <a class="nav-item" href="/archives">
                <span class="nav-text">归档</span>
            </a>
        
            <a class="nav-item" href="/atom.xml">
                <span class="nav-text">订阅</span>
            </a>
        
            <a class="nav-item" href="/about">
                <span class="nav-text">关于</span>
            </a>
        
    </nav>
</div>

    <aside id="aside" class="aside">
    <div id="aside-mask" class="aside-mask"></div>
    <div id="aside-inner" class="aside-inner">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit"><i class="icon-search-stroke"></i></button><input type="hidden" name="sitesearch" value="https://wxzhongwang.github.io"></form>

        
        

        
        <div class="author-meta">
            
            <div class="author-avatar">
                <a href="/">
                    <img src="/images/27359059.jpg" title="咸鱼有点咸">
                </a>
            </div>
            
            <div class="author-name">咸鱼有点咸</div>
            <div class="author-work">Developer</div>
            <div class="author-location">
                <i class="icon-location vm"></i>
                <span class="vm">Hangzhou, China</span>
            </div>
            
            <div class="author-thread-wrap">
                <div class="author-threads clearfix">
                    
                        <a class="thread-item" href="https://github.com/wxzhongwang" target="_blank" rel="noopener">
                            <!-- Generated by IcoMoon.io -->
<svg viewbox="0 0 1024 1024" width="38" height="38" fill="currentColor">
<path d="M512 32.12c-265.004 0-479.88 220.23-479.88 492.090 0 217.446 137.536 401.684 328.202 466.81 23.994 4.498 32.778-10.712 32.778-23.78 0-11.782-0.428-42.632-0.642-83.764-133.466 29.778-161.744-65.984-161.744-65.984-21.852-56.772-53.344-71.982-53.344-71.982-43.49-30.636 3.214-29.992 3.214-29.992 48.202 3.428 73.482 50.772 73.482 50.772 42.846 75.196 112.258 53.558 139.68 40.918 4.284-31.706 16.71-53.558 30.42-65.77-106.474-12.426-218.516-54.63-218.516-243.152 0-53.772 18.638-97.69 49.274-131.966-4.928-12.426-21.424-62.556 4.714-130.252 0 0 40.276-13.282 131.966 50.344 38.348-10.926 79.266-16.282 120.184-16.496 40.704 0.214 81.836 5.57 120.184 16.496 91.692-63.626 131.752-50.344 131.752-50.344 26.136 67.698 9.64 117.828 4.714 130.252 30.636 34.492 49.274 78.408 49.274 131.966 0 188.952-112.258 230.514-219.16 242.724 17.138 15.21 32.564 45.202 32.564 91.048 0 65.77-0.642 118.898-0.642 134.966 0 13.068 8.57 28.492 32.992 23.566 191.094-64.912 328.418-249.152 328.418-466.382 0-271.86-214.874-492.090-479.88-492.090z"/>
</svg>

                        </a>
                    
                        <a class="thread-item" href="https://weibo.com/u/6558527999" target="_blank" rel="noopener">
                            <!-- Generated by IcoMoon.io -->
<svg viewbox="0 0 1024 1024" width="38" height="38" fill="currentColor">
<path d="M21.332 512c0-270.988 219.68-490.666 490.668-490.666s490.666 219.68 490.666 490.666c0 270.988-219.678 490.666-490.666 490.666s-490.666-219.678-490.666-490.666zM960 512c0-247.424-200.576-448-448-448s-448 200.576-448 448c0 247.424 200.576 448 448 448s448-200.576 448-448zM768 597.332c47.128 0 85.332-38.206 85.332-85.332s-38.206-85.332-85.332-85.332c-47.128 0-85.332 38.204-85.332 85.332s38.206 85.332 85.332 85.332zM512 597.332c47.128 0 85.332-38.206 85.332-85.332s-38.206-85.332-85.332-85.332c-47.128 0-85.332 38.204-85.332 85.332s38.204 85.332 85.332 85.332zM255.998 597.332c47.128 0 85.332-38.206 85.332-85.332s-38.204-85.332-85.332-85.332c-47.128 0-85.332 38.204-85.332 85.332s38.204 85.332 85.332 85.332z"/>
</svg>

                        </a>
                    
                        <a class="thread-item" href="https://twitter.com/wxzhongwang" target="_blank" rel="noopener">
                            <!-- Generated by IcoMoon.io -->
<svg viewbox="0 0 1024 1024" width="38" height="38" fill="currentColor">
<path d="M512.029 31.011c-263.32 0-476.784 213.502-476.784 476.784 0 263.32 213.464 476.743 476.784 476.743s476.743-213.424 476.743-476.743c0-263.282-213.444-476.784-476.743-476.784zM752.193 411.663c0.251 5.151 0.349 10.319 0.349 15.548 0 158.786-120.856 341.85-341.85 341.85-67.844 0-131.021-19.884-184.188-53.961 9.41 1.104 18.955 1.665 28.656 1.665 56.305 0 108.115-19.208 149.221-51.425-52.567-0.987-96.925-35.741-112.22-83.468 7.32 1.433 14.85 2.149 22.595 2.149 10.959 0 21.569-1.433 31.656-4.201-54.987-11.035-96.402-59.634-96.402-117.796 0-0.524 0-1.025 0.020-1.549 16.186 9.003 34.716 14.404 54.427 15.044-32.258-21.587-53.458-58.317-53.458-100.023 0-22.015 5.925-42.673 16.264-60.408 59.266 72.683 147.807 120.527 247.676 125.521-2.053-8.77-3.118-17.968-3.118-27.378 0-66.333 53.787-120.14 120.158-120.14 34.561 0 65.771 14.599 87.69 37.93 27.378-5.363 53.091-15.393 76.305-29.16-9.003 28.074-28.036 51.618-52.858 66.47 24.338-2.903 47.495-9.37 69.024-18.917-16.070 24.144-36.459 45.306-59.945 62.248z"/>
</svg>

                        </a>
                    
                </div>
            </div>
            
        </div>
        
    </div>
</aside>

</header>

        <div id="content" class="content">
    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2018/12/02/Canal /">Canal准备</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="https://wxzhongwang.github.io/page/5/index.html">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2018-12-02T04:30:00.000Z" itemprop="datePublished">2018-12-02</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/Canal/">Canal</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>对于自建 MySQL , 需要先开启 Binlog 写入功能，配置 binlog-format 为 ROW 模式，my.cnf 中配置如下<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[mysqld]</span></span><br><span class="line"><span class="attr">log-bin</span>=mysql-bin <span class="comment"># 开启 binlog</span></span><br><span class="line"><span class="attr">binlog-format</span>=ROW <span class="comment"># 选择 ROW 模式</span></span><br><span class="line"><span class="attr">server_id</span>=<span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<p>配置 MySQL replaction 需要定义，不要和 canal 的 slaveId 重复</p>
<blockquote>
<p>注意：针对阿里云 RDS for MySQL , 默认打开了 binlog , 并且账号默认具有 binlog dump 权限 , 不需要任何权限或者 binlog 设置,可以直接跳过这一步<br>授权 canal 链接 MySQL 账号具有作为 MySQL slave 的权限, 如果已有账户可直接 grant<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> canal <span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span> <span class="string">'canal'</span>;  </span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span>, <span class="keyword">REPLICATION</span> <span class="keyword">SLAVE</span>, <span class="keyword">REPLICATION</span> <span class="keyword">CLIENT</span> <span class="keyword">ON</span> *.* <span class="keyword">TO</span> <span class="string">'canal'</span>@<span class="string">'%'</span>;</span><br><span class="line"><span class="comment">-- GRANT ALL PRIVILEGES ON *.* TO 'canal'@'%' ;</span></span><br><span class="line"><span class="keyword">FLUSH</span> <span class="keyword">PRIVILEGES</span>;</span><br></pre></td></tr></table></figure></p>
</blockquote>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2018/12/02/可靠事件通知/">（十）可靠事件通知</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="https://wxzhongwang.github.io/page/5/index.html">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2018-12-02T04:30:00.000Z" itemprop="datePublished">2018-12-02</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/分布式事务/">分布式事务</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h1 id="可靠事件通知"><a href="#可靠事件通知" class="headerlink" title="可靠事件通知"></a>可靠事件通知</h1><p>可靠事件通知模式的设计理念比较容易理解，即是主服务完成后将结果通过事件（常常是消息队列）传递给从服务，从服务在接受到消息后进行消费，完成业务，从而达到主服务与从服务间的消息一致性。首先能想到的也是最简单的就是同步事件通知，业务处理与消息发送同步执行，实现逻辑见下方代码及时序图。</p>
<h2 id="同步事件"><a href="#同步事件" class="headerlink" title="同步事件"></a>同步事件</h2><h3 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码:"></a>伪代码:</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trans</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">    <span class="comment">// 1. 操作数据库  </span></span><br><span class="line">        <span class="keyword">bool</span> result = dao.update(data);<span class="comment">// 操作数据库失败，会抛出异常  </span></span><br><span class="line">    <span class="comment">// 2. 如果数据库操作成功则发送消息  </span></span><br><span class="line">        <span class="keyword">if</span>(result)&#123;  </span><br><span class="line">            mq.send(data);<span class="comment">// 如果方法执行失败，会抛出异常  </span></span><br><span class="line">        &#125;  </span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;  </span><br><span class="line">        roolback();<span class="comment">// 如果发生异常，就回滚  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="理想化场景"><a href="#理想化场景" class="headerlink" title="理想化场景:"></a>理想化场景:</h3><p><img src="https://mmbiz.qpic.cn/mmbiz_png/Baq5lYpIw7UAmRmz9SHwLAkkzYRj8FzeVEmeiaahJE6OMa38XIug1eN2UYBW3XPDAHHXrJe8cictRf3mOOOfGdbw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="image"></p>
<p>上面的逻辑看上去天衣无缝，如果数据库操作失败则直接退出，不发送消息；如果发送消息失败，则数据库回滚；如果数据库操作成功且消息发送成功，则业务成功，消息发送给下游消费。然后仔细思考后，同步消息通知其实有==两点==不足的地方。</p>
<h3 id="不足之处"><a href="#不足之处" class="headerlink" title="不足之处"></a>不足之处</h3><ul>
<li>第一点：<br>在微服务的架构下，有可能出现网络IO问题或者服务器宕机的问题，如果这些问题出现在时序图的第7步，使得消息投递后无法正常通知主服务（网络问题），或无法继续提交事务（宕机），那么主服务将会认为消息投递失败，会滚主服务业务，然而实际上消息已经被从服务消费，那么就会造成主服务和从服务的数据不一致。具体场景可见下面两张时序图。</li>
</ul>
<h4 id="网络异常"><a href="#网络异常" class="headerlink" title="网络异常:"></a>网络异常:</h4><p><img src="https://mmbiz.qpic.cn/mmbiz_png/Baq5lYpIw7UAmRmz9SHwLAkkzYRj8FzePKpkYem9wEIwyp9YU4YV1Usib1iatBfXodicTzXw8qskcry4jJAgEVJ5w/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="image"></p>
<h4 id="服务器宕机"><a href="#服务器宕机" class="headerlink" title="服务器宕机:"></a>服务器宕机:</h4><p><img src="https://mmbiz.qpic.cn/mmbiz_png/Baq5lYpIw7UAmRmz9SHwLAkkzYRj8FzeO8Y0Rz0mIILzCB4XWf4Yia4U1nAeIQcVib9xseaKicIicmnbFR4biaIyHJg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="image"></p>
<ul>
<li>第二点 ：事件服务（在这里就是消息服务）与业务过于耦合，如果消息服务不可用，会导致业务不可用。应该将事件服务与业务解耦，独立出来异步执行，或者在业务执行后先尝试发送一次消息，如果消息发送失败，则降级为异步发送。</li>
<li></li>
</ul>
<h2 id="异步事件"><a href="#异步事件" class="headerlink" title="异步事件"></a>异步事件</h2><h3 id="本地事件服务"><a href="#本地事件服务" class="headerlink" title="本地事件服务"></a>本地事件服务</h3><p>为了解决前面描述的同步事件的问题，异步事件通知模式被发展了出来，既业务服务和事件服务解耦，事件异步进行，由单独的事件服务保证事件的可靠投递。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/Baq5lYpIw7UAmRmz9SHwLAkkzYRj8FzeymQcemYABBK50naIib5837TU5P0iauWiag7dHZ1YicL6dIph4HF6ia6Qibiag/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="image"></p>
<p>异步事件通知－本地事件服务</p>
<p>当业务执行时，在同一个本地事务中将事件写入本地事件表，同时投递该事件，如果事件投递成功，则将该事件从事件表中删除。如果投递失败，则使用事件服务定时地异步统一处理投递失败的事件，进行重新投递，直到事件被正确投递，并将事件从事件表中删除。这种方式最大可能地保证了事件投递的实效性，并且当第一次投递失败后，也能使用异步事件服务保证事件至少被投递一次。</p>
<p>然而，这种使用本地事件服务保证可靠事件通知的方式也有它的不足之处，那便是业务仍旧与事件服务有一定耦合（第一次同步投递时），更为严重的是，本地事务需要负责额外的事件表的操作，为数据库带来了压力，在高并发的场景，由于每一个业务操作就要产生相应的事件表操作，几乎将数据库的可用吞吐量砍了一半，这无疑是无法接受的。正是因为这样的原因，可靠事件通知模式进一步地发展－外部事件服务出现在了人们的眼中。</p>
<h3 id="外部事件服务"><a href="#外部事件服务" class="headerlink" title="外部事件服务"></a>外部事件服务</h3><p>外部事件服务在本地事件服务的基础上更进了一步，将事件服务独立出主业务服务，主业务服务不在对事件服务有任何强依赖。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/Baq5lYpIw7UAmRmz9SHwLAkkzYRj8FzeaBIY5Ff9r6jKEutSBesV0OadfdAqkPN3CvYgUpo4pe0NKxGgFelfRw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="image"></p>
<p>异步事件通知－外部事件服务</p>
<p>业务服务在提交前，向事件服务发送事件，事件服务只记录事件，并不发送。业务服务在提交或回滚后通知事件服务，事件服务发送事件或者删除事件。不用担心业务系统在提交或者会滚后宕机而无法发送确认事件给事件服务，因为事件服务会定时获取所有仍未发送的事件并且向业务系统查询，根据业务系统的返回来决定发送或者删除该事件。</p>
<p>外部事件虽然能够将业务系统和事件系统解耦，但是也带来了额外的工作量：外部事件服务比起本地事件服务来说多了两次网络通信开销（提交前、提交／回滚后），同时也需要业务系统提供单独的查询接口给事件系统用来判断未发送事件的状态。</p>
<h5 id="流程梳理"><a href="#流程梳理" class="headerlink" title="流程梳理"></a>流程梳理</h5><ol>
<li>首先事务发起方先往 MQ 发送一条预读消息，这条消息与普通消息的区别在于他只对 MQ 可见不会向下传播。</li>
<li>MQ接受到消息后，先进行持久化，则存储中会新增一条状态为待发送的消息，接着给事务发起方返回处理完成的 ACK；事务发起方收到处理完成的 ACK 之后开始执行本地事务。</li>
<li>发起方会根据本地事务的执行状态来决定这个预读消息是应该继续往前还是回滚。另外 MQ 也应该支持自己反查来解决异常情况，如果发起方本地事务已经执行完毕发送消息到MQ,但是消息因为网络原因丢失，那么怎么解决。所以这个反查机制很重要。</li>
<li>本地事务执行成功以后，MQ 也接收到成功通知，接着将消息状态更新为可发送，然后将消息推送给下游的消费者，这个时候消费者就可以去处理自己的本地事务 。</li>
</ol>
<p>注意点：由于MQ通常都会保证消息能够投递成功，因此，如果业务没有及时返回ACK结果，那么就有可能造成MQ的重复消息投递问题。因此，对于消息最终一致性的方案，消息的消费者必须要对消息的消费支持幂等，不能造成同一条消息的重复消费的情况。</p>
<h2 id="可靠事件通知注意事项"><a href="#可靠事件通知注意事项" class="headerlink" title="可靠事件通知注意事项"></a>可靠事件通知注意事项</h2><p>可靠事件模式需要注意的有两点，1. 事件的正确发送；2. 事件的重复消费。</p>
<p>通过异步消息服务可以确保事件的正确发送，然而事件是有可能重复发送的，那么就需要消费端保证同一条事件不会重复被消费，简而言之就是保证事件消费的 ==幂等性==<br>。</p>
<p>如果事件本身是具备幂等性的状态型事件，如订单状态的通知（已下单、已支付、已发货等），则需要判断事件的顺序。一般通过时间戳来判断，既消费过了新的消息后，当接受到老的消息直接丢弃不予消费。如果无法提供全局时间戳，则应考虑使用全局统一的序列号。</p>
<p>对于不具备幂等性的事件，一般是动作行为事件，如扣款100，存款200，则应该将事件id及事件结果持久化，在消费事件前查询事件id，若已经消费则直接返回执行结果；若是新消息，则执行，并存储执行结果。</p>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2018/12/02/单机版本Nacos/">nacos单机模式支持mysql</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="https://wxzhongwang.github.io/page/5/index.html">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2018-12-02T04:30:00.000Z" itemprop="datePublished">2018-12-02</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/SpringCloud/">SpringCloud</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h1 id="单机模式支持mysql"><a href="#单机模式支持mysql" class="headerlink" title="单机模式支持mysql"></a>单机模式支持mysql</h1><p>在0.7版本之前，在单机模式时nacos使用嵌入式数据库实现数据的存储，不方便观察数据存储的基本情况。0.7版本增加了支持mysql数据源能力，具体的操作步骤：</p>
<ol>
<li>安装数据库，版本要求：5.6.5+</li>
<li>初始化mysql数据库，数据库初始化文件：nacos-mysql.sql</li>
<li>修改conf/application.properties文件，增加支持mysql数据源配置（目前只支持mysql），添加mysql数据源的url、用户名和密码。</li>
</ol>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring.datasource.platform</span>=mysql</span><br><span class="line"></span><br><span class="line"><span class="attr">db.num</span>=<span class="number">1</span></span><br><span class="line"><span class="attr">db.url.0</span>=jdbc:mysql://<span class="number">11.162</span>.<span class="number">196.16</span>:<span class="number">3306</span>/nacos_devtest?characterEncoding=utf8&amp;connectTimeout=<span class="number">1000</span>&amp;socketTimeout=<span class="number">3000</span>&amp;autoReconnect=<span class="literal">true</span></span><br><span class="line"><span class="attr">db.user</span>=nacos_devtest</span><br><span class="line"><span class="attr">db.password</span>=youdontknow</span><br></pre></td></tr></table></figure>
        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2018/12/02/缓存雪崩、缓存穿透、缓存预热、缓存更新、缓存降级/">缓存雪崩、缓存穿透、缓存预热、缓存更新、缓存降级</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="https://wxzhongwang.github.io/page/5/index.html">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2018-12-02T04:30:00.000Z" itemprop="datePublished">2018-12-02</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/Redis/">Redis</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h1 id="缓存雪崩、缓存穿透、缓存预热、缓存更新、缓存降级"><a href="#缓存雪崩、缓存穿透、缓存预热、缓存更新、缓存降级" class="headerlink" title="缓存雪崩、缓存穿透、缓存预热、缓存更新、缓存降级"></a>缓存雪崩、缓存穿透、缓存预热、缓存更新、缓存降级</h1><p><a href="https://www.cnblogs.com/leeSmall/p/8594542.html" target="_blank" rel="noopener">参考</a> </p>
<h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p>缓存雪崩我们可以简单的理解为：由于原有缓存失效，新缓存未到期间(例如：我们设置缓存时采用了相同的过期时间，在同一时刻出现大面积的缓存过期)，所有原本应该访问缓存的请求都去查询数据库了，而对数据库CPU和内存造成巨大压力，严重的会造成数据库宕机。从而形成一系列连锁反应，造成整个系统崩溃。</p>
<p>缓存正常从Redis中获取，示意图如下：</p>
<p><img src="http://p1.pstatp.com/large/pgc-image/1521269040783ad8b0b3415" alt="image"></p>
<p>缓存失效瞬间示意图如下：</p>
<p><img src="http://p3.pstatp.com/large/pgc-image/15212690408812aad2545bb" alt="image"></p>
<p>解决方案:</p>
<p>（1）碰到这种情况，一般并发量不是特别多的时候，使用最多的解决方案是加锁排队，伪代码如下：<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public Object getProductListNew()&#123;</span><br><span class="line">    int <span class="keyword">cacheTime </span>= <span class="number">30</span><span class="comment">;</span></span><br><span class="line">    String <span class="keyword">cacheKey </span>= <span class="string">"product_list"</span><span class="comment">;</span></span><br><span class="line">    String localKey = <span class="keyword">cacheKey;</span></span><br><span class="line"><span class="keyword"> </span>   </span><br><span class="line">    String <span class="keyword">cacheValue </span>= <span class="keyword">CacheHelper.get(cacheKey);</span></span><br><span class="line"><span class="keyword"> </span>   if(<span class="keyword">cacheValue </span>!= null)&#123;</span><br><span class="line">        return <span class="keyword">cacheValue;</span></span><br><span class="line"><span class="keyword"> </span>   &#125; else &#123;</span><br><span class="line">        sychronized(localKey)&#123;</span><br><span class="line">            if(<span class="keyword">cacheValue </span>!= null)&#123;</span><br><span class="line">                 return <span class="keyword">cacheValue;</span></span><br><span class="line"><span class="keyword"> </span>           &#125; else  &#123;</span><br><span class="line">                <span class="keyword">cacheValue </span>= getProductListFromDB()<span class="comment">;</span></span><br><span class="line">                <span class="keyword">CacheHelper.add(cacheKey, </span><span class="keyword">cacheValue, </span><span class="keyword">cacheTime);</span></span><br><span class="line"><span class="keyword"> </span>           &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        return <span class="keyword">cacheValue;</span></span><br><span class="line"><span class="keyword"> </span>   &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>加锁排队只是为了减轻数据库的压力，并没有提高系统吞吐量。假设在高并发下，缓存重建期间key是锁着的，这是过来1000个请求999个都在阻塞的。同样会导致用户等待超时，这是个治标不治本的方法！</p>
<p>注意：加锁排队的解决方式分布式环境的并发问题，有可能还要解决分布式锁的问题；线程还会被阻塞，用户体验很差！因此，在真正的高并发场景下很少使用！</p>
<p>（2）给每一个缓存数据增加相应的缓存标记，记录缓存的是否失效，如果缓存标记失效，则更新数据缓存，实例伪代码如下：</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">Object</span> getProductListNew()&#123;</span><br><span class="line">    <span class="built_in">int</span> cacheTime = <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">String</span> cacheKey = <span class="string">"product_list"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//缓存标记 </span></span><br><span class="line">    <span class="keyword">String</span> cacheSign = cacheKey + <span class="string">"_sign"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">String</span> sign = CacheHelper.<span class="built_in">get</span>(cacheSign);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">String</span> cacheValue = CacheHelper.<span class="built_in">get</span>(cacheKey);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(sign != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> cacheValue;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//过期 </span></span><br><span class="line">        CacheHelper.<span class="built_in">add</span>(cacheSign, <span class="number">1</span>, cacheTime);</span><br><span class="line">        ThreadPool.QueueUserWorkItem((arg -&gt; &#123;</span><br><span class="line">            cacheValue = getProductListFromDB();</span><br><span class="line">            CacheHelper.<span class="built_in">add</span>(cacheKey, cacheValue, cacheTime * <span class="number">2</span>);</span><br><span class="line">        &#125;));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> cacheValue;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解释说明：</p>
<p>1、缓存标记：记录缓存数据是否过期，如果过期会触发通知另外的线程在后台去更新实际key的缓存；</p>
<p>2、缓存数据：它的过期时间比缓存标记的时间延长1倍，例：标记缓存时间30分钟，数据缓存设置为60分钟。 这样，当缓存标记key过期后，实际缓存还能把旧数据返回给调用端，直到另外的线程在后台更新完成后，才会返回新缓存。</p>
<p>关于缓存崩溃的解决方法，这里提出了三种方案：使用锁或队列、设置过期标志更新缓存、为key设置不同的缓存失效时间，还有一各被称为“二级缓存”的解决方法，有兴趣的读者可以自行研究。</p>
<h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p>缓存穿透是指用户查询数据，在数据库没有，自然在缓存中也不会有。这样就导致用户查询的时候，在缓存中找不到，每次都要去数据库再查询一遍，然后返回空（相当于进行了两次无用的查询）。这样请求就绕过缓存直接查数据库，这也是经常提的缓存命中率问题。</p>
<p> 缓存穿透解决方案：</p>
<p>（1）采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。</p>
<p>（2）如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。通过这个直接设置的默认值存放到缓存，这样第二次到缓存中获取就有值了，而不会继续访问数据库，这种办法最简单粗暴！ 把空结果也给缓存起来，这样下次同样的请求就可以直接返回空了，即可以避免当查询的值为空时引起的缓存穿透。同时也可以单独设置个缓存区域存储空值，对要查询的key进行预先校验，然后再放行给后面的正常缓存处理逻辑。</p>
<h2 id="缓存预热"><a href="#缓存预热" class="headerlink" title="缓存预热"></a>缓存预热</h2><p> 缓存预热就是系统上线后，提前将相关的缓存数据直接加载到缓存系统。避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据！</p>
<p> 缓存预热解决方案：</p>
<ul>
<li><p>（1）直接写个缓存刷新页面，上线时手工操作下；</p>
</li>
<li><p>（2）数据量不大，可以在项目启动的时候自动进行加载；</p>
</li>
<li><p>（3）定时刷新缓存；</p>
</li>
</ul>
<h2 id="缓存更新"><a href="#缓存更新" class="headerlink" title="缓存更新"></a>缓存更新</h2><p>除了缓存服务器自带的缓存失效策略之外（Redis默认的有6中策略可供选择），我们还可以根据具体的业务需求进行自定义的缓存淘汰，常见的策略有两种：</p>
<p>（1）定时去清理过期的缓存；</p>
<p>（2）当有用户请求过来时，再判断这个请求所用到的缓存是否过期，过期的话就去底层系统得到新数据并更新缓存。</p>
<p>两者各有优劣，第一种的缺点是维护大量缓存的key是比较麻烦的，第二种的缺点就是每次用户请求过来都要判断缓存失效，逻辑相对比较复杂！具体用哪种方案，大家可以根据自己的应用场景来权衡。</p>
<h2 id="缓存降级"><a href="#缓存降级" class="headerlink" title="缓存降级"></a>缓存降级</h2><p>当访问量剧增、服务出现问题（如响应时间慢或不响应）或非核心服务影响到核心流程的性能时，仍然需要保证服务还是可用的，即使是有损服务。系统可以根据一些关键数据进行自动降级，也可以配置开关实现人工降级。</p>
<p>降级的最终目的是保证核心服务可用，即使是有损的。而且有些服务是无法降级的（如加入购物车、结算）。</p>
<p>在进行降级之前要对系统进行梳理，看看系统是不是可以丢卒保帅；从而梳理出哪些必须誓死保护，哪些可降级；比如可以参考日志级别设置预案：</p>
<p>（1）一般：比如有些服务偶尔因为网络抖动或者服务正在上线而超时，可以自动降级；</p>
<p>（2）警告：有些服务在一段时间内成功率有波动（如在95~100%之间），可以自动降级或人工降级，并发送告警；</p>
<p>（3）错误：比如可用率低于90%，或者数据库连接池被打爆了，或者访问量突然猛增到系统能承受的最大阀值，此时可以根据情况自动降级或者人工降级；</p>
<p>（4）严重错误：比如因为特殊原因数据错误了，此时需要紧急人工降级。</p>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2018/12/02/windows 搭建consul/">windows 搭建consul</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="https://wxzhongwang.github.io/page/5/index.html">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2018-12-02T04:30:00.000Z" itemprop="datePublished">2018-12-02</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/SpringCloud/">SpringCloud</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h1 id="windows-搭建consul"><a href="#windows-搭建consul" class="headerlink" title="windows 搭建consul"></a>windows 搭建consul</h1><p><a href="https://blog.csdn.net/qq_19663899/article/details/83341881" target="_blank" rel="noopener">windows 搭建consul</a></p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">cmd 命令窗口执行：consul agent -dev</span><br><span class="line"></span><br><span class="line">consul 自带 UI 界面，打开网址：http:<span class="regexp">//</span>localhost:<span class="number">8500</span> ，可以看到当前注册的服务界面</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">创建服务</span><br><span class="line">sc create consul binPath= <span class="string">"C:\consul1.9.0\consul_1.9.0_windows_amd64\consul.exe agent -server -ui -bootstrap -client 0.0.0.0 -data-dir="</span>C:\consul1.<span class="number">9.0</span>\data-di<span class="string">r" -bind 172.16.129.139"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">consul.exe agent -server -ui -bootstrap -client <span class="number">0.0</span>.<span class="number">0.0</span> -data-dir=<span class="string">"C:\consul1.9.0\data-dir"</span> -bind <span class="number">172.16</span>.xx.<span class="number">139</span></span><br></pre></td></tr></table></figure>
        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2018/12/02/tomcat最大线程数的设置/">tomcat最大线程数的设置</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="https://wxzhongwang.github.io/page/5/index.html">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2018-12-02T04:30:00.000Z" itemprop="datePublished">2018-12-02</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/Java/">Java</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h1 id="tomcat最大线程数的设置"><a href="#tomcat最大线程数的设置" class="headerlink" title="tomcat最大线程数的设置"></a>tomcat最大线程数的设置</h1><p>Tomcat的server.xml中连接器设置如下</p>
<h2 id="1-Tomcat配置"><a href="#1-Tomcat配置" class="headerlink" title="1.Tomcat配置"></a>1.Tomcat配置</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;Connector <span class="attribute">port</span>=<span class="string">"8080"</span>     </span><br><span class="line">   <span class="attribute">maxThreads</span>=<span class="string">"150"</span> <span class="attribute">minSpareThreads</span>=<span class="string">"25"</span> <span class="attribute">maxSpareThreads</span>=<span class="string">"75"</span>     </span><br><span class="line">   <span class="attribute">enableLookups</span>=<span class="string">"false"</span> <span class="attribute">redirectPort</span>=<span class="string">"8443"</span> <span class="attribute">acceptCount</span>=<span class="string">"100"</span>     </span><br><span class="line">   <span class="attribute">debug</span>=<span class="string">"0"</span> <span class="attribute">connectionTimeout</span>=<span class="string">"20000"</span>      </span><br><span class="line">   <span class="attribute">disableUploadTimeout</span>=<span class="string">"true"</span> /&gt;</span><br></pre></td></tr></table></figure>
<h2 id="2-如何加大tomcat连接数"><a href="#2-如何加大tomcat连接数" class="headerlink" title="2.如何加大tomcat连接数"></a>2.如何加大tomcat连接数</h2><p>在tomcat配置文件server.xml中的<connector>配置中，和连接数相关的参数有：</connector></p>
<ul>
<li>minProcessors：最小空闲连接线程数，用于提高系统处理性能，默认值为10</li>
<li>maxProcessors：最大连接线程数，即：并发处理的最大请求数，默认值为75</li>
<li>acceptCount：允许的最大连接数，应大于等于maxProcessors，默认值为100</li>
<li>enableLookups：是否反查域名，取值为：true或false。为了提高处理能力，应设置为false</li>
<li>connectionTimeout：网络连接超时，单位：毫秒。设置为0表示永不超时，这样设置有隐患的。通常可设置为30000毫秒。</li>
</ul>
<p>其中和最大连接数相关的参数为maxProcessors和acceptCount。如果要加大并发连接数，应同时加大这两个参数。<br>web server允许的最大连接数还受制于操作系统的内核参数设置，通常Windows是2000个左右，Linux是1000个左右。tomcat5中的配置示例：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;Connector <span class="attribute">port</span>=<span class="string">"8080"</span></span><br><span class="line">   <span class="attribute">maxThreads</span>=<span class="string">"150"</span> <span class="attribute">minSpareThreads</span>=<span class="string">"25"</span> <span class="attribute">maxSpareThreads</span>=<span class="string">"75"</span></span><br><span class="line">   <span class="attribute">enableLookups</span>=<span class="string">"false"</span> <span class="attribute">redirectPort</span>=<span class="string">"8443"</span> <span class="attribute">acceptCount</span>=<span class="string">"100"</span></span><br><span class="line">   <span class="attribute">debug</span>=<span class="string">"0"</span> <span class="attribute">connectionTimeout</span>=<span class="string">"20000"</span></span><br><span class="line">   <span class="attribute">disableUploadTimeout</span>=<span class="string">"true"</span> /&gt;</span><br></pre></td></tr></table></figure></p>
<p>对于其他端口的侦听配置，以此类推。</p>
<h2 id="3-tomcat中如何禁止列目录下的文件"><a href="#3-tomcat中如何禁止列目录下的文件" class="headerlink" title="3.tomcat中如何禁止列目录下的文件"></a>3.tomcat中如何禁止列目录下的文件</h2><p>在{tomcat_home}/conf/web.xml中，把listings参数设置成false即可，如下：</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;init-<span class="built_in">param</span>&gt;  </span><br><span class="line">    &lt;<span class="built_in">param</span>-name&gt;listings&lt;/<span class="built_in">param</span>-name&gt;  </span><br><span class="line">    &lt;<span class="built_in">param</span>-<span class="built_in">value</span>&gt;<span class="literal">false</span>&lt;/<span class="built_in">param</span>-<span class="built_in">value</span>&gt;  </span><br><span class="line">&lt;/init-<span class="built_in">param</span>&gt;</span><br></pre></td></tr></table></figure>
<h2 id="4-如何加大tomcat可以使用的内存"><a href="#4-如何加大tomcat可以使用的内存" class="headerlink" title="4.如何加大tomcat可以使用的内存"></a>4.如何加大tomcat可以使用的内存</h2><p>tomcat默认可以使用的内存为128MB，在较大型的应用项目中，这点内存是不够的，需要调大。<br>Unix下，在文件{tomcat_home}/bin/catalina.sh的前面，增加如下设置：<br>JAVA_OPTS=’-Xms【初始化内存大小】 -Xmx【可以使用的最大内存】’<br>需要把这个两个参数值调大。例如：<br>JAVA_OPTS=’-Xms256m -Xmx512m’<br>表示初始化内存为256MB，可以使用的最大内存为512MB</p>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2018/12/02/nacos 部署方式/">nacos 部署方式</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="https://wxzhongwang.github.io/page/5/index.html">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2018-12-02T04:30:00.000Z" itemprop="datePublished">2018-12-02</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/SpringCloud/">SpringCloud</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h1 id="nacos-部署方式"><a href="#nacos-部署方式" class="headerlink" title="nacos 部署方式"></a>nacos 部署方式</h1><p><a href="https://nacos.io/zh-cn/docs/what-is-nacos.html" target="_blank" rel="noopener">nacos you should know</a></p>
<p>Nacos支持三种部署模式</p>
<ul>
<li>单机模式 - 用于测试和单机试用。</li>
<li>集群模式 - 用于生产环境，确保高可用。</li>
<li>多集群模式 - 用于多数据中心场景。</li>
</ul>
<p>单机模式下运行Nacos</p>
<blockquote>
<p>Standalone means it is non-cluster Mode. * </p>
</blockquote>
<ol>
<li><p>Linux/Unix/Mac</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sh </span>startup.<span class="keyword">sh </span>-m standalone</span><br></pre></td></tr></table></figure>
</li>
<li><p>Windows</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmd</span><span class="bash"> startup.cmd -m standalone</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>单机模式支持mysql<br>在0.7版本之前，在单机模式时nacos使用嵌入式数据库实现数据的存储，不方便观察数据存储的基本情况。0.7版本增加了支持mysql数据源能力，具体的操作步骤：</p>
<ol>
<li>安装数据库，版本要求：5.6.5+</li>
<li>初始化mysql数据库，数据库初始化文件：nacos-mysql.sql</li>
<li>修改conf/application.properties文件，增加支持mysql数据源配置（目前只支持mysql），添加mysql数据源的url、用户名和密码。</li>
</ol>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring.datasource.platform</span>=mysql</span><br><span class="line"></span><br><span class="line"><span class="attr">db.num</span>=<span class="number">1</span></span><br><span class="line"><span class="attr">db.url.0</span>=jdbc:mysql://<span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">3306</span>/nacos_config?characterEncoding=utf8&amp;connectTimeout=<span class="number">1000</span>&amp;socketTimeout=<span class="number">3000</span>&amp;autoReconnect=<span class="literal">true</span></span><br><span class="line"><span class="attr">db.user</span>=nacos_config</span><br><span class="line"><span class="attr">db.password</span>=youdontknow</span><br></pre></td></tr></table></figure>
        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2018/12/02/集群版本Nacos/">集群Nacos</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="https://wxzhongwang.github.io/page/5/index.html">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2018-12-02T04:30:00.000Z" itemprop="datePublished">2018-12-02</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/SpringCloud/">SpringCloud</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h1 id="集群Nacos"><a href="#集群Nacos" class="headerlink" title="集群Nacos"></a>集群Nacos</h1><h2 id="工作模式："><a href="#工作模式：" class="headerlink" title="工作模式："></a>工作模式：</h2><p>因此开源的时候推荐用户把所有服务列表放到一个vip下面，然后挂到一个域名下面</p>
<p><a href="http://ip1:port/openAPI" target="_blank" rel="noopener">http://ip1:port/openAPI</a> 直连ip模式，机器挂则需要修改ip才可以使用。</p>
<p><a href="http://VIP:port/openAPI" target="_blank" rel="noopener">http://VIP:port/openAPI</a> 挂载VIP模式，直连vip即可，下面挂server真实ip，可读性不好。</p>
<p><a href="http://nacos.com:port/openAPI" target="_blank" rel="noopener">http://nacos.com:port/openAPI</a> 域名 + VIP模式，可读性好，而且换ip方便，推荐模式</p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/jpeg/338441/1561258986171-4ddec33c-a632-4ec3-bfff-7ef4ffc33fb9.jpeg" alt="工作模式"></p>
<h2 id="环境说明："><a href="#环境说明：" class="headerlink" title="环境说明："></a>环境说明：</h2><ol>
<li>64 bit OS Linux/Unix/Mac，推荐使用Linux系统。</li>
<li>64 bit JDK 1.8+；下载.配置。</li>
<li>Maven 3.2.x+；下载.配置。</li>
<li>3个或3个以上Nacos节点才能构成集群。</li>
</ol>
<h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>使用源码编译：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">unzip nacos-source.zip</span><br><span class="line">cd nacos/</span><br><span class="line">mvn -Prelease-nacos clean <span class="keyword">install</span> -U  </span><br><span class="line">cd nacos/distribution/target/nacos-<span class="keyword">server</span><span class="number">-1.3</span><span class="number">.0</span>/nacos/<span class="keyword">bin</span></span><br></pre></td></tr></table></figure></p>
<p>直接使用压缩包：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">unzip nacos-server-<span class="number">1.3</span>.<span class="number">0</span>.zip</span><br><span class="line">or</span><br><span class="line">tar -xvf nacos-server-<span class="number">1.3</span>.<span class="number">0</span><span class="selector-class">.tar</span><span class="selector-class">.gz</span></span><br><span class="line"></span><br><span class="line">cd nacos/bin</span><br></pre></td></tr></table></figure></p>
<h2 id="配置集群配置文件"><a href="#配置集群配置文件" class="headerlink" title="配置集群配置文件"></a>配置集群配置文件</h2><p>在nacos的解压目录nacos/的conf目录下，有配置文件cluster.conf，请每行配置成ip:port。（请配置3个或3个以上节点）<br><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">ip1:</span><span class="number">8848</span></span><br><span class="line"><span class="symbol">ip2:</span><span class="number">8848</span></span><br><span class="line"><span class="symbol">ip3:</span><span class="number">8848</span></span><br></pre></td></tr></table></figure></p>
<h2 id="确定数据源"><a href="#确定数据源" class="headerlink" title="确定数据源"></a>确定数据源</h2><h3 id="使用内置数据源"><a href="#使用内置数据源" class="headerlink" title="使用内置数据源"></a>使用内置数据源</h3><p>无需进行任何配置</p>
<h3 id="使用外置数据源"><a href="#使用外置数据源" class="headerlink" title="使用外置数据源"></a>使用外置数据源</h3><p>生产使用建议至少主备模式，或者采用高可用数据库。</p>
<h2 id="初始化-MySQL-数据库"><a href="#初始化-MySQL-数据库" class="headerlink" title="初始化 MySQL 数据库"></a>初始化 MySQL 数据库</h2><p>在nacos的解压目录nacos/的conf目录下，存在sql文件 nacos-mysql.sql</p>
<h2 id="修改application-properties-配置"><a href="#修改application-properties-配置" class="headerlink" title="修改application.properties 配置"></a>修改application.properties 配置</h2><p>application.properties配置文件</p>
<h2 id="启动服务器"><a href="#启动服务器" class="headerlink" title="启动服务器"></a>启动服务器</h2><p>Linux/Unix/Mac<br>Stand-alone mode<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sh </span>startup.<span class="keyword">sh </span>-m standalone</span><br></pre></td></tr></table></figure></p>
<p>集群模式 + 使用内置数据源<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh startup<span class="selector-class">.sh</span> -<span class="selector-tag">p</span> embedded</span><br></pre></td></tr></table></figure></p>
<p>集群模式 + 使用外置数据源<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sh</span> startup.<span class="keyword">sh</span></span><br></pre></td></tr></table></figure></p>
<h2 id="服务注册发现-和-配置管理"><a href="#服务注册发现-和-配置管理" class="headerlink" title="服务注册发现 和 配置管理"></a>服务注册发现 和 配置管理</h2><p>服务注册<br><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X PUT 'http://127.0.0.1:<span class="number">8848</span>/nacos/v1/ns/instance?serviceName=nacos.naming.serviceName&amp;ip=20.18.7.10&amp;port=<span class="number">8080</span>'</span><br></pre></td></tr></table></figure></p>
<p>服务发现<br><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X GET 'http://127.0.0.1:<span class="number">8848</span>/nacos/v1/ns/instances?serviceName=nacos.naming.serviceName'</span><br></pre></td></tr></table></figure></p>
<p>发布配置<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">curl</span> -X POST <span class="string">"http://127.0.0.1:8848/nacos/v1/cs/configs?dataId=nacos.cfg.dataId&amp;group=test&amp;content=helloWorld"</span></span><br></pre></td></tr></table></figure></p>
<p>获取配置<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X <span class="builtin-name">GET</span> <span class="string">"http://127.0.0.1:8848/nacos/v1/cs/configs?dataId=nacos.cfg.dataId&amp;group=test"</span></span><br></pre></td></tr></table></figure></p>
<h2 id="关闭服务器"><a href="#关闭服务器" class="headerlink" title="关闭服务器"></a>关闭服务器</h2><p>Linux/Unix/Mac<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sh</span> shutdown.<span class="keyword">sh</span></span><br></pre></td></tr></table></figure></p>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2018/12/02/git ssh http 协议切换 /">git ssh http 协议切换</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="https://wxzhongwang.github.io/page/5/index.html">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2018-12-02T04:30:00.000Z" itemprop="datePublished">2018-12-02</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/Git/">Git</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h1 id="git-ssh-http-协议切换"><a href="#git-ssh-http-协议切换" class="headerlink" title="git ssh http 协议切换"></a>git ssh http 协议切换</h1><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># 先看一下远端地址是否自己想要的</span></span><br><span class="line">git remote -v </span><br><span class="line"><span class="meta"># 不是就移除</span></span><br><span class="line">git remote remove origin</span><br><span class="line"><span class="meta"># 添加新的</span></span><br><span class="line">git remote add origin http:<span class="comment">//172.16.5.77/HTDATA/CHD-Energy-Project.git</span></span><br><span class="line"><span class="meta"># 再看看</span></span><br><span class="line">git remote -v </span><br><span class="line"><span class="meta"># 合个代码试试</span></span><br><span class="line">git fetch origin</span><br><span class="line">git rebase origin/master</span><br><span class="line"><span class="meta"># 推个代码试试</span></span><br><span class="line">git push origin mingbai-dev</span><br></pre></td></tr></table></figure>
        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2018/12/02/事务的隔离级别/">事务的隔离级别</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="https://wxzhongwang.github.io/page/5/index.html">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2018-12-02T04:30:00.000Z" itemprop="datePublished">2018-12-02</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/分布式事务/">分布式事务</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h1 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h1><h2 id="为何需要设置数据库隔离级别？"><a href="#为何需要设置数据库隔离级别？" class="headerlink" title="为何需要设置数据库隔离级别？"></a>为何需要设置数据库隔离级别？</h2><p>在数据库操作中，在并发的情况下可能出现如下问题：</p>
<ul>
<li>更新丢失（Lost Update）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">不论后面的数据库更新是否提交，都有可能让前面的更新丢失。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>如果多个线程操作，基于同一个查询结构对表中的记录进行修改，那么后修改的记录将会覆盖前面修改的记录，前面的修改就丢失掉了，这就叫做更新丢失。这是因为系统没有执行任何的锁操作，因此并发事务并没有被隔离开来。 </p>
<blockquote>
<p>第 1 类丢失更新：事务A撤销时，把已经提交的事务B的更新数据覆盖了。 </p>
</blockquote>
<table>
<thead>
<tr>
<th>时间</th>
<th>取款事务A</th>
<th>取款事务B</th>
</tr>
</thead>
<tbody>
<tr>
<td>T1</td>
<td>开始事务</td>
<td></td>
</tr>
<tr>
<td>T2</td>
<td></td>
<td>开始事务</td>
</tr>
<tr>
<td>T3</td>
<td>查询余额为1000元</td>
<td></td>
</tr>
<tr>
<td>T4</td>
<td></td>
<td>查询余额为1000元</td>
</tr>
<tr>
<td>T5</td>
<td></td>
<td>汇入100元，修改余额为1100元</td>
</tr>
<tr>
<td>T6</td>
<td></td>
<td>提交事务</td>
</tr>
<tr>
<td>T7</td>
<td>取款100元， 修改余额为900元</td>
<td></td>
</tr>
<tr>
<td>T8</td>
<td>撤销事务</td>
<td></td>
</tr>
<tr>
<td>T9</td>
<td>余额回复为1000元（丢失更新）</td>
<td></td>
</tr>
</tbody>
</table>
<blockquote>
<p>第 2 类丢失更新：事务A覆盖事务B已经提交的数据，造成事务B所做的操作丢失。</p>
</blockquote>
<table>
<thead>
<tr>
<th>时间</th>
<th>取款事务A</th>
<th>取款事务B</th>
</tr>
</thead>
<tbody>
<tr>
<td>T1</td>
<td></td>
<td>开始事务</td>
</tr>
<tr>
<td>T2</td>
<td>开始事务</td>
<td></td>
</tr>
<tr>
<td>T3</td>
<td></td>
<td>查询余额为1000元</td>
</tr>
<tr>
<td>T4</td>
<td>查询余额为1000元</td>
<td></td>
</tr>
<tr>
<td>T5</td>
<td></td>
<td>取款100元， 修改余额为900元</td>
</tr>
<tr>
<td>T6</td>
<td></td>
<td>提交事务</td>
</tr>
<tr>
<td>T7</td>
<td>汇入100元，修改余额为1100元</td>
<td></td>
</tr>
<tr>
<td>T8</td>
<td>提交事务</td>
<td></td>
</tr>
<tr>
<td>T9</td>
<td>余额回复为1100元（丢失更新）</td>
<td></td>
</tr>
</tbody>
</table>
<blockquote>
<p>解决方法：对行加锁，只允许并发一个更新事务。</p>
</blockquote>
<ul>
<li>脏读（Dirty Read）<blockquote>
<p>脏读（Dirty Read）：A事务读取B事务尚未提交的数据并在此基础上操作，而B事务执行回滚，那么A读取到的数据就是脏数据。</p>
</blockquote>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">读到了别的事务回滚前的脏数据</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>时间</th>
<th>取款事务A</th>
<th>取款事务B</th>
</tr>
</thead>
<tbody>
<tr>
<td>T1</td>
<td></td>
<td>开始事务</td>
</tr>
<tr>
<td>T2</td>
<td>开始事务</td>
<td></td>
</tr>
<tr>
<td>T3</td>
<td></td>
<td>查询余额为1000元</td>
</tr>
<tr>
<td>T4</td>
<td></td>
<td>取出500元，余额为500元</td>
</tr>
<tr>
<td>T5</td>
<td>查询余额为500元 （脏读）</td>
<td></td>
</tr>
<tr>
<td>T6</td>
<td></td>
<td>撤销事务，余额恢复为1000元</td>
</tr>
<tr>
<td>T7</td>
<td>汇入100元，修改余额600元</td>
<td></td>
</tr>
<tr>
<td>T8</td>
<td>提交事务</td>
<td></td>
</tr>
</tbody>
</table>
<blockquote>
<p>解决办法：如果在第一个事务提交前，任何其他事务不可读取其修改过的值，则可以避免该问题。</p>
</blockquote>
<ul>
<li>不可重复读（Non-repeatable Reads） <blockquote>
<p>一个事务对同一行数据重复读取两次，但是却得到了不同的结果。事务T1读取某一数据后，事务T2对其做了修改，当事务T1再次读该数据时得到与前一次不同的值。</p>
</blockquote>
</li>
</ul>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一个事务中两次读取的数据的内容不一致 <span class="comment">(一般基于行而言)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">事务<span class="keyword">A</span>首先读取了一条数据，然后执行逻辑的时候，事务B将这条数据改变了，</span><br><span class="line">然后事务<span class="keyword">A</span>再次读取的时候，发现数据不匹配了，就是不可重复读</span><br><span class="line"></span><br><span class="line">同一数据，在一个事务的两次读取之间存在另一更新、删除的事务。</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>时间</th>
<th>取款事务A</th>
<th>取款事务B</th>
</tr>
</thead>
<tbody>
<tr>
<td>T1</td>
<td></td>
<td>开始事务</td>
</tr>
<tr>
<td>T2</td>
<td>开始事务</td>
<td></td>
</tr>
<tr>
<td>T3</td>
<td></td>
<td>查询余额为1000元</td>
</tr>
<tr>
<td>T4</td>
<td>查询余额为1000元</td>
<td></td>
</tr>
<tr>
<td>T5</td>
<td></td>
<td>取出100元，修改余额为900元</td>
</tr>
<tr>
<td>T6</td>
<td></td>
<td>提交事务</td>
</tr>
<tr>
<td>T7</td>
<td>查询余额为900元（不可重复读）</td>
<td></td>
</tr>
</tbody>
</table>
<blockquote>
<p>解决办法：如果只有在修改事务完全提交之后才可以读取数据，则可以避免该问题。</p>
</blockquote>
<ul>
<li>幻读<blockquote>
<p>指两次执行同一条 select语句会出现不同的结果，第二次读会增加一数据行，并没有说这两次执行是在同一个事务中。一般情况下，幻象读应该正是我们所需要的。但有时候却不是，如果打开的游标，在对游标进行操作时，并不希望新增的记录加到游标命中的数据集中来。隔离级别为游标稳定性的，可以阻止幻象读。例如：目前工资为1000的员工有10人。那么事务1中读取所有工资为1000的员工，得到了10条记录；这时事务2向员工表插入了一条员工记录，工资也为1000；那么事务1再次读取所有工资为1000的员工共读取到了11条记录。 </p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一个事务中两次读取的数据的数量不一致 <span class="comment">(一般基于表而言)</span></span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">事务<span class="keyword">A</span>首先根据条件索引得到N条数据，</span><br><span class="line">然后事务B改变了这N条数据之外的M条或者增添了M条符合事务<span class="keyword">A</span>搜索条件的数据，</span><br><span class="line">导致事务<span class="keyword">A</span>再次搜索发现有N+M条数据了，就产生了幻读。</span><br><span class="line"></span><br><span class="line">同一数据，在一个事务中的两次（读取）写入之间存在另一插入的事务。</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>时间</th>
<th>统计金额事务A</th>
<th>转账事务B</th>
</tr>
</thead>
<tbody>
<tr>
<td>T1</td>
<td></td>
<td>开始事务</td>
</tr>
<tr>
<td>T2</td>
<td>开始事务</td>
<td></td>
</tr>
<tr>
<td>T3</td>
<td>统计总存款为10000元</td>
<td></td>
</tr>
<tr>
<td>T4</td>
<td></td>
<td>新增一个存款账户转入100元</td>
</tr>
<tr>
<td>T5</td>
<td></td>
<td>提交事务</td>
</tr>
<tr>
<td>T7</td>
<td>再次统计总存款为10100元</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="不可重复读和幻读比较："><a href="#不可重复读和幻读比较：" class="headerlink" title="不可重复读和幻读比较："></a>不可重复读和幻读比较：</h3><blockquote>
<p>两者有些相似，但是前者针对的是update或delete，后者针对的insert。</p>
</blockquote>
<h2 id="隔离级别包括哪些？"><a href="#隔离级别包括哪些？" class="headerlink" title="隔离级别包括哪些？"></a>隔离级别包括哪些？</h2><p>数据库事务的隔离级别有4个，由低到高依次为</p>
<ul>
<li>Read uncommitted   (未提交读 ==》 读未提交)</li>
</ul>
<p>如果一个事务已经开始写数据，则另外一个事务则不允许同时进行写操作，但允许其他事务读此行数据。该隔离级别可以通过 <strong>排他写锁</strong> 实现。这样就避免了更新丢失，却可能出现脏读。也就是说事务B读取到了事务A未提交的数据。</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">通俗来说就是，事务A开始写，事务<span class="keyword">B不能写，只能读。可能出现脏读。</span></span><br><span class="line"><span class="keyword">（读到未提交的数据）</span></span><br></pre></td></tr></table></figure>
<ul>
<li>Read committed    （提交读 ==》 读已提交）</li>
</ul>
<p>读取数据的事务允许其他事务继续访问该行数据，但是未提交的写事务将会禁止其他事务访问该行。该隔离级别避免了脏读，但是却可能出现不可重复读。事务A事先读取了数据，事务B紧接了更新了数据，并提交了事务，而事务A再次读取该数据时，数据已经发生了改变。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">通俗来讲就是，读数据都可以，一旦有事务开始写，会禁止其他事务访问该行。</span><br><span class="line">避免脏读，可能出现不可重复读。</span><br><span class="line">（同一事务读取一行数据，两次结果不一致，后面一次读取时，数据已经发生改变）</span><br></pre></td></tr></table></figure>
<ul>
<li>Repeatable read   （可重复读）</li>
</ul>
<p>可重复读是指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。那么，在第一个事务中的两次读数据之间，即使第二个事务对数据进行修改，第一个事务两次读到的的数据是一样的。这样就发生了在一个事务内两次读到的数据是一样的，因此称为是可重复读。读取数据的事务将会禁止写事务（但允许读事务），写事务则禁止任何其他事务。这样避免了不可重复读取和脏读，但是有时可能出现幻象读。（读取数据的事务）这可以通过“共享读锁”和“排他写锁”实现。</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">在一个事务内，多次读同一数据。在事务未提交前，另一事务也在访问同一数据，</span><br><span class="line">在第一个事务两次读之间，即使第二个事务修改数据，第一个数据的两次读到的数据仍然是一致的。</span><br><span class="line"></span><br><span class="line">避免了不可重复读和脏读。</span><br><span class="line"></span><br><span class="line">读事务，禁止写（允许读事务）。</span><br><span class="line">写事务，禁止任何其他事务。</span><br><span class="line"></span><br><span class="line">可能出现幻读 eg：</span><br><span class="line"><span class="number">1.</span> 先更新某一列为从‘<span class="number">1</span>’更新为‘<span class="number">2</span>’ </span><br><span class="line"><span class="number">2.</span> 插入一行，该里值仍未‘<span class="number">1</span>’</span><br><span class="line"><span class="number">3.</span> 再次读取仍读到列值为‘<span class="number">1</span>’的数据</span><br></pre></td></tr></table></figure>
<ul>
<li>Serializable      （串行化）</li>
</ul>
<p>提供严格的事务隔离。它要求事务序列化执行，事务只能一个接着一个地执行，但不能并发执行。如果仅仅通过“行级锁”是无法实现事务序列化的，必须通过其他机制保证新插入的数据不会被刚执行查询操作的事务访问到。序列化是最高的事务隔离级别，同时代价也花费最高，性能很低，一般很少使用，在该级别下，事务顺序执行，不仅可以避免脏读、不可重复读，还避免了幻像读。</p>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
<th>第一类丢失更新</th>
<th>第二类丢失更新</th>
</tr>
</thead>
<tbody>
<tr>
<td>读未提交</td>
<td>允许</td>
<td>允许</td>
<td>允许</td>
<td>不允许</td>
<td>允许 </td>
</tr>
<tr>
<td>读已提交</td>
<td>不允许</td>
<td>允许</td>
<td>允许</td>
<td>不允许</td>
<td>允许</td>
</tr>
<tr>
<td>可重复读</td>
<td>不允许</td>
<td>不允许</td>
<td>允许</td>
<td>不允许</td>
<td>不允许</td>
</tr>
<tr>
<td>串行化</td>
<td>不允许</td>
<td>不允许</td>
<td>不允许</td>
<td>不允许</td>
<td>不允许</td>
</tr>
</tbody>
</table>

        
    </section>
</article>




<nav class="page-nav">
    <a class="extend prev" rel="prev" href="/page/4/">&laquo; 上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><span class="space">&hellip;</span><a class="page-number" href="/page/23/">23</a><a class="extend next" rel="next" href="/page/6/">下一页 &raquo;</a>
</nav>


</div>
        <footer class="footer">
    Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, Theme by <a href="https://github.com/sanonz/hexo-theme-concise" target="_blank">Concise</a>

    
    <script>
        var _hmt = _hmt || [];
        (function () {
            var hm = document.createElement("script");
            hm.src = "https://hm.baidu.com/hm.js?e4027971a230b210f4671f485b33846a";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();
    </script>
    
</footer>

    </main>

    <script type="text/javascript" src="https://cdn.bootcss.com/jquery/1.9.0/jquery.min.js"></script>
    <script type="text/javascript">
    $(function() {
        var nodes = {
            nav: $('#nav'),
            aside: $('#aside'),
            asideInner: $('#aside-inner'),
            navInner: $('#nav-inner')
        };

        var doing = false;
        nodes.asideInner.on('webkitAnimationEnd mozAnimationEnd oAnimationEnd oanimationend animationend', function() {
            if (nodes.aside.hasClass('mobile-open')) {
                nodes.aside.removeClass('mobile-open');
            } else {
                nodes.aside.removeClass('mobile-close panel-show');
            }
            doing = false;
        });
        $('#open-panel, #aside-mask').on('click', function() {
            if (doing) {
                return;
            }
            
            if (nodes.aside.hasClass('panel-show')) {
                nodes.aside.addClass('mobile-close');
            } else {
                nodes.aside.addClass('mobile-open panel-show');
            }
        });
        $('#open-menus').on('click', function() {
            nodes.navInner.slideToggle();
        });

        if (window.innerWidth <= 960) {
            setTimeout(function() {
                nodes.navInner.slideUp();
            }, 3000);
        }
    });
    </script>
    

</body>
</html>
