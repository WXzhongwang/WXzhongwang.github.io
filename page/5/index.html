<!DOCTYPE html>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="UTF-8">

    

    

    <title>我喜欢你喜欢我的歌</title>
    <meta name="author" content="Dick Zhong">
    <meta name="version" content="1.0.0">
    <meta name="keywords" content>
    <meta name="description" content>
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">

    
    <link rel="alternate" href="/atom.xml" title="我喜欢你喜欢我的歌" type="application/atom+xml">
    
    
    <link rel="icon" href="/images/favicon.ico">
    

    <link rel="stylesheet" href="/css/style.css">
</head>
<body>

    <main class="app">
        <header class="header clearfix">
    <div id="nav" class="nav">
    <div class="nav-mobile">
        <button id="open-panel" class="open-panel nav-mobile-item"><i class="icon-documents"></i></button>
        <h1 class="nav-mobile-title nav-mobile-item">我喜欢你喜欢我的歌</h1>
        <button id="open-menus" class="open-panel nav-mobile-item"><i class="icon-library"></i></button>
    </div>

    <nav id="nav-inner" class="nav-inner">
        
            <a class="nav-item active" href="/">
                <span class="nav-text">首页</span>
            </a>
        
            <a class="nav-item" href="/categories/">
                <span class="nav-text">分类</span>
            </a>
        
            <a class="nav-item" href="/tags">
                <span class="nav-text">标签</span>
            </a>
        
            <a class="nav-item" href="/archives">
                <span class="nav-text">归档</span>
            </a>
        
            <a class="nav-item" href="/atom.xml">
                <span class="nav-text">订阅</span>
            </a>
        
            <a class="nav-item" href="/about">
                <span class="nav-text">关于</span>
            </a>
        
    </nav>
</div>

    <aside id="aside" class="aside">
    <div id="aside-mask" class="aside-mask"></div>
    <div id="aside-inner" class="aside-inner">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit"><i class="icon-search-stroke"></i></button><input type="hidden" name="sitesearch" value="https://wxzhongwang.github.io"></form>

        
        

        
        <div class="author-meta">
            
            <div class="author-avatar">
                <a href="/">
                    <img src="/images/27359059.jpg" title="咸鱼有点咸">
                </a>
            </div>
            
            <div class="author-name">咸鱼有点咸</div>
            <div class="author-work">Developer</div>
            <div class="author-location">
                <i class="icon-location vm"></i>
                <span class="vm">Hangzhou, China</span>
            </div>
            
            <div class="author-thread-wrap">
                <div class="author-threads clearfix">
                    
                        <a class="thread-item" href="https://github.com/wxzhongwang" target="_blank" rel="noopener">
                            <!-- Generated by IcoMoon.io -->
<svg viewbox="0 0 1024 1024" width="38" height="38" fill="currentColor">
<path d="M512 32.12c-265.004 0-479.88 220.23-479.88 492.090 0 217.446 137.536 401.684 328.202 466.81 23.994 4.498 32.778-10.712 32.778-23.78 0-11.782-0.428-42.632-0.642-83.764-133.466 29.778-161.744-65.984-161.744-65.984-21.852-56.772-53.344-71.982-53.344-71.982-43.49-30.636 3.214-29.992 3.214-29.992 48.202 3.428 73.482 50.772 73.482 50.772 42.846 75.196 112.258 53.558 139.68 40.918 4.284-31.706 16.71-53.558 30.42-65.77-106.474-12.426-218.516-54.63-218.516-243.152 0-53.772 18.638-97.69 49.274-131.966-4.928-12.426-21.424-62.556 4.714-130.252 0 0 40.276-13.282 131.966 50.344 38.348-10.926 79.266-16.282 120.184-16.496 40.704 0.214 81.836 5.57 120.184 16.496 91.692-63.626 131.752-50.344 131.752-50.344 26.136 67.698 9.64 117.828 4.714 130.252 30.636 34.492 49.274 78.408 49.274 131.966 0 188.952-112.258 230.514-219.16 242.724 17.138 15.21 32.564 45.202 32.564 91.048 0 65.77-0.642 118.898-0.642 134.966 0 13.068 8.57 28.492 32.992 23.566 191.094-64.912 328.418-249.152 328.418-466.382 0-271.86-214.874-492.090-479.88-492.090z"/>
</svg>

                        </a>
                    
                        <a class="thread-item" href="https://weibo.com/u/6558527999" target="_blank" rel="noopener">
                            <!-- Generated by IcoMoon.io -->
<svg viewbox="0 0 1024 1024" width="38" height="38" fill="currentColor">
<path d="M21.332 512c0-270.988 219.68-490.666 490.668-490.666s490.666 219.68 490.666 490.666c0 270.988-219.678 490.666-490.666 490.666s-490.666-219.678-490.666-490.666zM960 512c0-247.424-200.576-448-448-448s-448 200.576-448 448c0 247.424 200.576 448 448 448s448-200.576 448-448zM768 597.332c47.128 0 85.332-38.206 85.332-85.332s-38.206-85.332-85.332-85.332c-47.128 0-85.332 38.204-85.332 85.332s38.206 85.332 85.332 85.332zM512 597.332c47.128 0 85.332-38.206 85.332-85.332s-38.206-85.332-85.332-85.332c-47.128 0-85.332 38.204-85.332 85.332s38.204 85.332 85.332 85.332zM255.998 597.332c47.128 0 85.332-38.206 85.332-85.332s-38.204-85.332-85.332-85.332c-47.128 0-85.332 38.204-85.332 85.332s38.204 85.332 85.332 85.332z"/>
</svg>

                        </a>
                    
                        <a class="thread-item" href="https://twitter.com/wxzhongwang" target="_blank" rel="noopener">
                            <!-- Generated by IcoMoon.io -->
<svg viewbox="0 0 1024 1024" width="38" height="38" fill="currentColor">
<path d="M512.029 31.011c-263.32 0-476.784 213.502-476.784 476.784 0 263.32 213.464 476.743 476.784 476.743s476.743-213.424 476.743-476.743c0-263.282-213.444-476.784-476.743-476.784zM752.193 411.663c0.251 5.151 0.349 10.319 0.349 15.548 0 158.786-120.856 341.85-341.85 341.85-67.844 0-131.021-19.884-184.188-53.961 9.41 1.104 18.955 1.665 28.656 1.665 56.305 0 108.115-19.208 149.221-51.425-52.567-0.987-96.925-35.741-112.22-83.468 7.32 1.433 14.85 2.149 22.595 2.149 10.959 0 21.569-1.433 31.656-4.201-54.987-11.035-96.402-59.634-96.402-117.796 0-0.524 0-1.025 0.020-1.549 16.186 9.003 34.716 14.404 54.427 15.044-32.258-21.587-53.458-58.317-53.458-100.023 0-22.015 5.925-42.673 16.264-60.408 59.266 72.683 147.807 120.527 247.676 125.521-2.053-8.77-3.118-17.968-3.118-27.378 0-66.333 53.787-120.14 120.158-120.14 34.561 0 65.771 14.599 87.69 37.93 27.378-5.363 53.091-15.393 76.305-29.16-9.003 28.074-28.036 51.618-52.858 66.47 24.338-2.903 47.495-9.37 69.024-18.917-16.070 24.144-36.459 45.306-59.945 62.248z"/>
</svg>

                        </a>
                    
                </div>
            </div>
            
        </div>
        
    </div>
</aside>

</header>

        <div id="content" class="content">
    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2018/12/08/消息队列/">消息队列</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="https://wxzhongwang.github.io/page/5/index.html">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2018-12-08T03:18:02.000Z" itemprop="datePublished">2018-12-08</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/消息队列/">消息队列</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h1 id="一、消息队列的基本概念"><a href="#一、消息队列的基本概念" class="headerlink" title="一、消息队列的基本概念"></a>一、消息队列的基本概念</h1><h2 id="1-1-Broker"><a href="#1-1-Broker" class="headerlink" title="1.1 Broker"></a>1.1 Broker</h2><p>==Broker== 的概念来自与Apache ActiveMQ，通俗的讲就是消息队列服务器。</p>
<h2 id="1-2-消息生产者和消费者"><a href="#1-2-消息生产者和消费者" class="headerlink" title="1.2 消息生产者和消费者"></a>1.2 消息生产者和消费者</h2><ul>
<li>消息生产者 ==Producer==：发送消息到消息队列。</li>
<li>消息消费者 ==Consumer==：从消息队列接收消息。</li>
</ul>
<h2 id="1-3-消息模型"><a href="#1-3-消息模型" class="headerlink" title="1.3 消息模型"></a>1.3 消息模型</h2><h3 id="点对点消息队列模型"><a href="#点对点消息队列模型" class="headerlink" title="点对点消息队列模型"></a>点对点消息队列模型</h3><p>消息生产者向一个特定的队列发送消息，消息消费者从该队列中接收消息。消息的生产者和消费者可以不同时处于运行状态。每一个成功处理的消息都由消息消费者签收确认（Acknowledge）。</p>
<h3 id="发布订阅消息模型-Topic"><a href="#发布订阅消息模型-Topic" class="headerlink" title="发布订阅消息模型-Topic"></a>发布订阅消息模型-Topic</h3><p>发布订阅消息模型中，支持向一个特定的主题Topic发布消息，0个或多个订阅者接收来自这个消息主题的消息。在这种模型下，发布者和订阅者彼此不知道对方。实际操作过程中，必须先订阅，再发送消息，而后接收订阅的消息，这个顺序必须保证。 </p>
<h2 id="1-4-消息顺序性保证"><a href="#1-4-消息顺序性保证" class="headerlink" title="1.4 消息顺序性保证"></a>1.4 消息顺序性保证</h2><p>基于Queue消息模型，利用FIFO先进先出的特性，可以保证消息的顺序性。</p>
<h2 id="1-5-消息的ACK确认机制"><a href="#1-5-消息的ACK确认机制" class="headerlink" title="1.5 消息的ACK确认机制"></a>1.5 消息的ACK确认机制</h2><p>即消息的Ackownledge确认机制：<br>为了保证消息不丢失，消息队列提供了消息Acknowledge机制，即ACK机制，当Consumer确认消息已经消费处理，发送一个ACK给消息队列，此时消息队列便可以删除这个消息了。如果Consumer宕机/关闭，没有发送ACK，消息队列将认为这个消息没有被处理，会将这个消息重新发送给其他的Consumer重新消费处理。</p>
<h2 id="1-6-消息的持久化"><a href="#1-6-消息的持久化" class="headerlink" title="1.6 消息的持久化"></a>1.6 消息的持久化</h2><p>消息的持久化，对于一些关键的核心业务来说是非常重要的，启用消息持久化后，消息队列宕机重启后，消息可以从持久化存储恢复，消息不丢失，可以继续消费处理。</p>
<h2 id="1-7-消息的同步和异步收发"><a href="#1-7-消息的同步和异步收发" class="headerlink" title="1.7 消息的同步和异步收发"></a>1.7 消息的同步和异步收发</h2><h3 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h3><p>消息的收发支持同步收发的方式<br>同步收发场景下，消息生产者和消费者双向应答模式，例如：张三写封信送到邮局中转站，然后李四从中转站获得信，然后在写一份回执信，放到中转站，然后张三去取，当然张三写信的时候就得写明回信地址。<br>消息的接收如果以同步的方式(Pull)进行接收，如果队列中为空，此时接收将处于同步阻塞状态，会一直等待，直到消息的到达。</p>
<h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><p>消息的收发同样支持异步方式：异步发送消息，不需要等待消息队列的接收确认。<br>异步接收消息，以Push的方式触发消息消费者接收消息。</p>
<h2 id="1-8-消息的事务支持"><a href="#1-8-消息的事务支持" class="headerlink" title="1.8 消息的事务支持"></a>1.8 消息的事务支持</h2><p>消息的收发处理支持事务，例如：在任务中心场景中，一次处理可能涉及多个消息的接收、处理，这处于同一个事务范围内，如果一个消息处理失败，事务回滚，消息重新回到队列中。</p>
<h1 id="二、JMS消费服务"><a href="#二、JMS消费服务" class="headerlink" title="二、JMS消费服务"></a>二、JMS消费服务</h1><p>Java消息服务（Java Message Service，JMS）应用程序接口是一个Java平台中关于面向消息中间件（MOM）的API，用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。 点对点与发布订阅最初是由JMS定义的。这两种模式主要区别或解决的问题就是发送到队列的消息能否重复消费(多订阅) 。</p>
<p>JMS规范目前支持两种消息模型：</p>
<ol>
<li>点对点（point to point， queue）</li>
<li>发布/订阅（publish/subscribe，topic）</li>
</ol>
<h2 id="2-1-点对点：Queue，不可重复消费"><a href="#2-1-点对点：Queue，不可重复消费" class="headerlink" title="2.1 点对点：Queue，不可重复消费"></a>2.1 点对点：Queue，不可重复消费</h2><p>消息生产者生产消息发送到queue中，然后消息消费者从queue中取出并且消费消息。<br>消息被消费以后，queue中不再有存储，所以消息消费者不可能消费到已经被消费的消息。<br>Queue支持存在多个消费者，但是对一个消息而言，只会有一个消费者可以消费。 </p>
<p>P2P模式包含三个角色：</p>
<ul>
<li>消息队列（Queue）</li>
<li>发送者(Sender)</li>
<li>接收者(Receiver)</li>
</ul>
<p>每个消息都被发送到一个特定的队列，接收者从队列中获取消息。队列保留着消息，<br>直到他们被消费或超时。</p>
<h2 id="2-2-发布-订阅：Topic，可以重复消费"><a href="#2-2-发布-订阅：Topic，可以重复消费" class="headerlink" title="2.2 发布/订阅：Topic，可以重复消费"></a>2.2 发布/订阅：Topic，可以重复消费</h2><p>消息生产者（发布）将消息发布到topic中，同时有多个消息消费者（订阅）消费该消息。<br>和点对点方式不同，发布到topic的消息会被所有订阅者消费。 </p>
<p>支持订阅组的发布订阅模式：<br>发布订阅模式下，当发布者消息量很大时，显然单个订阅者的处理能力是不足的。实际上现实场景中是多个订阅者节点组成一个订阅组负载均衡消费topic消息即分组订阅，这样订阅者很容易实现消费能力线性扩展。可以看成是一个topic下有多个Queue，每个Queue是点对点的方式，Queue之间是发布订阅方式。 </p>
<h2 id="2-3-区别"><a href="#2-3-区别" class="headerlink" title="2.3 区别"></a>2.3 区别</h2><h3 id="点对点模式"><a href="#点对点模式" class="headerlink" title="点对点模式"></a>点对点模式</h3><p>生产者发送一条消息到queue，一个queue可以有很多消费者，但是一个消息只能被一个消费者接受，当没有消费者可用时，这个消息会被保存直到有一个可用的消费者，所以Queue实现了一个可靠的负载均衡。</p>
<h3 id="发布订阅模式"><a href="#发布订阅模式" class="headerlink" title="发布订阅模式"></a>发布订阅模式</h3><p>发布者发送到topic的消息，只有订阅了topic的订阅者才会收到消息。topic实现了发布和订阅，当你发布一个消息，所有订阅这个topic的服务都能得到这个消息，所以从1到N个订阅者都能得到这个消息的拷贝。</p>
<h1 id="三、流行模型对比"><a href="#三、流行模型对比" class="headerlink" title="三、流行模型对比"></a>三、流行模型对比</h1><p>传统企业型消息队列ActiveMQ遵循了JMS规范，实现了点对点和发布订阅模型，但其他流行的消息队列RabbitMQ、Kafka并没有遵循JMS规范。</p>
<h2 id="3-1-RabbitMQ"><a href="#3-1-RabbitMQ" class="headerlink" title="3.1 RabbitMQ"></a>3.1 RabbitMQ</h2><p>RabbitMQ实现了AQMP协议，AQMP协议定义了消息路由规则和方式。生产端通过路由规则发送消息到不同queue，消费端根据queue名称消费消息。RabbitMQ既支持内存队列也支持持久化队列，消费端为推模型，消费状态和订阅关系由服务端负责维护，消息消费完后立即删除，不保留历史消息。</p>
<h3 id="点对点"><a href="#点对点" class="headerlink" title="点对点"></a>点对点</h3><p>生产端发送一条消息通过路由投递到Queue，只有一个消费者能消费到。 </p>
<h3 id="多订阅"><a href="#多订阅" class="headerlink" title="多订阅"></a>多订阅</h3><p>当RabbitMQ需要支持多订阅时，发布者发送的消息通过路由同时写到多个Queue，不同订阅组消费不同的Queue。所以支持多订阅时，消息会多个拷贝。 </p>
<h2 id="3-2-Kafka"><a href="#3-2-Kafka" class="headerlink" title="3.2 Kafka"></a>3.2 Kafka</h2><p>Kafka只支持消息持久化，消费端为拉模型，消费状态和订阅关系由客户端端负责维护，消息消费完后不会立即删除，会保留历史消息。因此支持多订阅时，消息只会存储一份就可以了。但是可能产生重复消费的情况。</p>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2018/12/02/事务/">（一）什么是事务</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="https://wxzhongwang.github.io/page/5/index.html">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2018-12-02T04:30:00.000Z" itemprop="datePublished">2018-12-02</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/分布式事务/">分布式事务</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h2 id="什么是事务？"><a href="#什么是事务？" class="headerlink" title="什么是事务？"></a>什么是事务？</h2><p>事务由一组操作构成，我们希望这组操作能够全部正确执行，如果这一组操作中的任意一个步骤发生错误，那么就需要回滚之前已经完成的操作。也就是同一个事务中的所有操作，要么全都正确执行，要么全都不要执行。</p>
<h2 id="事务的四大特性-ACID"><a href="#事务的四大特性-ACID" class="headerlink" title="事务的四大特性 ACID"></a>事务的四大特性 ACID</h2><p>说到事务，就不得不提一下事务著名的四大特性。</p>
<h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>原子性要求，事务是一个不可分割的执行单元，事务中的所有操作要么全都执行，要么全都不执行。</p>
<h3 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h3><p>一致性要求，事务在开始前和结束后，数据库的完整性约束没有被破坏。</p>
<h3 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h3><p>事务的执行是相互独立的，它们不会相互干扰，一个事务不会看到另一个正在运行过程中的事务的数据。</p>
<h3 id="持久性"><a href="#持久性" class="headerlink" title="持久性"></a>持久性</h3><p>持久性要求，一个事务完成之后，事务的执行结果必须是持久化保存的。即使数据库发生崩溃，在数据库恢复后事务提交的结果仍然不会丢失。</p>
<p>注意：事务只能保证数据库的高可靠性，即数据库本身发生问题后，事务提交后的数据仍然能恢复；而如果不是数据库本身的故障，如硬盘损坏了，那么事务提交的数据可能就丢失了。这属于『高可用性』的范畴。因此，事务只能保证数据库的『高可靠性』，而『高可用性』需要整个系统共同配合实现。</p>
<h2 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h2><p>这里扩展一下，对事务的隔离性做一个详细的解释。</p>
<p>在事务的四大特性ACID中，要求的隔离性是一种严格意义上的隔离，也就是多个事务是串行执行的，彼此之间不会受到任何干扰。这确实能够完全保证数据的安全性，但在实际业务系统中，这种方式性能不高。因此，数据库定义了四种隔离级别，隔离级别和数据库的性能是呈反比的，隔离级别越低，数据库性能越高，而隔离级别越高，数据库性能越差。</p>
<p>事务并发执行会出现的问题<br>我们先来看一下在不同的隔离级别下，数据库可能会出现的问题：</p>
<h3 id="更新丢失"><a href="#更新丢失" class="headerlink" title="更新丢失"></a>更新丢失</h3><p>当有两个并发执行的事务，更新同一行数据，那么有可能一个事务会把另一个事务的更新覆盖掉。<br>当数据库没有加任何锁操作的情况下会发生。</p>
<h3 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h3><p>一个事务读到另一个尚未提交的事务中的数据。<br>该数据可能会被回滚从而失效。<br>如果第一个事务拿着失效的数据去处理那就发生错误了。</p>
<h3 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h3><p>不可重复度的含义：一个事务对同一行数据读了两次，却得到了不同的结果。</p>
<p>在事务1两次读取同一记录的过程中，事务2对该记录进行了修改，从而事务1第二次读到了不一样的记录。</p>
<h3 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h3><p>事务1在两次查询的过程中，事务2对该表进行了插入、删除操作，从而事务1第二次查询的结果发生了变化。</p>
<blockquote>
<p>不可重复读 与 脏读 的区别？</p>
<ul>
<li>脏读读到的是尚未提交的数据，而不可重复读读到的是已经提交的数据，只不过在两次读的过程中数据被另一个事务改过了。</li>
</ul>
</blockquote>
<h2 id="数据库的四种隔离级别"><a href="#数据库的四种隔离级别" class="headerlink" title="数据库的四种隔离级别"></a>数据库的四种隔离级别</h2><p>数据库一共有如下四种隔离级别：</p>
<h3 id="Read-uncommitted-读未提交"><a href="#Read-uncommitted-读未提交" class="headerlink" title="Read uncommitted 读未提交"></a>Read uncommitted 读未提交</h3><p>在该级别下，一个事务对一行数据修改的过程中，不允许另一个事务对该行数据进行修改，但允许另一个事务对该行数据读。<br>因此本级别下，不会出现更新丢失，但会出现脏读、不可重复读。</p>
<h3 id="Read-committed-读提交"><a href="#Read-committed-读提交" class="headerlink" title="Read committed 读提交"></a>Read committed 读提交</h3><p>在该级别下，未提交的写事务不允许其他事务访问该行，因此不会出现脏读；但是读取数据的事务允许其他事务的访问该行数据，因此会出现不可重复读的情况。</p>
<h3 id="Repeatable-read-重复读"><a href="#Repeatable-read-重复读" class="headerlink" title="Repeatable read 重复读"></a>Repeatable read 重复读</h3><p>在该级别下，读事务禁止写事务，但允许读事务，因此不会出现同一事务两次读到不同的数据的情况（不可重复读），且写事务禁止其他一切事务。</p>
<h3 id="Serializable-序列化"><a href="#Serializable-序列化" class="headerlink" title="Serializable 序列化"></a>Serializable 序列化</h3><p>该级别要求所有事务都必须串行执行，因此能避免一切因并发引起的问题，但效率很低。</p>
<p>隔离级别越高，越能保证数据的完整性和一致性，但是对并发性能的影响也越大。对于多数应用程序，可以优先考虑把数据库系统的隔离级别设为Read Committed。它能够避免脏读取，而且具有较好的并发性能。尽管它会导致不可重复读、幻读和第二类丢失更新这些并发问题，在可能出现这类问题的个别场合，可以由应用程序采用悲观锁或乐观锁来控制。</p>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2018/12/02/个人面试遇到的一些问题/">线上排查基本操作</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="https://wxzhongwang.github.io/page/5/index.html">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2018-12-02T04:30:00.000Z" itemprop="datePublished">2018-12-02</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/JVM/">JVM</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h1 id="1-Dubbo-Zk-如何实现动态选择负载均衡策略"><a href="#1-Dubbo-Zk-如何实现动态选择负载均衡策略" class="headerlink" title="1. Dubbo + Zk 如何实现动态选择负载均衡策略"></a>1. Dubbo + Zk 如何实现动态选择负载均衡策略</h1><h1 id="2-Nginx-能实现哪些功能？-如何修改请求头？"><a href="#2-Nginx-能实现哪些功能？-如何修改请求头？" class="headerlink" title="2. Nginx 能实现哪些功能？ 如何修改请求头？"></a>2. Nginx 能实现哪些功能？ 如何修改请求头？</h1><pre><code>静态代理（资源托管）
反向代理（请求转发）

方式一：proxy_set_header
proxy_set_header   iden    &quot;student&quot;;
proxy_set_header   age     &quot;21&quot;;

方式二：set 方式
set $iden &quot;student&quot;;
set $age &quot;21&quot;;
</code></pre><h1 id="3-Java-什么时候会发生锁升级为重量级锁？"><a href="#3-Java-什么时候会发生锁升级为重量级锁？" class="headerlink" title="3. Java 什么时候会发生锁升级为重量级锁？"></a>3. Java 什么时候会发生锁升级为重量级锁？</h1><pre><code>（锁膨胀）
</code></pre><h1 id="4-HashMap并发过程中出现CPU崩溃？什么原因？"><a href="#4-HashMap并发过程中出现CPU崩溃？什么原因？" class="headerlink" title="4. HashMap并发过程中出现CPU崩溃？什么原因？"></a>4. HashMap并发过程中出现CPU崩溃？什么原因？</h1><pre><code>https://blog.csdn.net/c929833623lvcha/article/details/8924414?utm_source=jiancool
</code></pre><h1 id="5-ConcurrentHashMap-锁具体实现原理？"><a href="#5-ConcurrentHashMap-锁具体实现原理？" class="headerlink" title="5. ConcurrentHashMap 锁具体实现原理？"></a>5. ConcurrentHashMap 锁具体实现原理？</h1><h1 id="6-SpringCloud-熔断机制，客户端如何捕获异常？"><a href="#6-SpringCloud-熔断机制，客户端如何捕获异常？" class="headerlink" title="6. SpringCloud 熔断机制，客户端如何捕获异常？"></a>6. SpringCloud 熔断机制，客户端如何捕获异常？</h1><h1 id="7-Zookeeper的选举机制？一定是过半选举么？"><a href="#7-Zookeeper的选举机制？一定是过半选举么？" class="headerlink" title="7. Zookeeper的选举机制？一定是过半选举么？"></a>7. Zookeeper的选举机制？一定是过半选举么？</h1><h1 id="8-Redis-实现分布式锁？"><a href="#8-Redis-实现分布式锁？" class="headerlink" title="8. Redis 实现分布式锁？"></a>8. Redis 实现分布式锁？</h1><pre><code>SETNX 原理
</code></pre><h1 id="9-MySQL-索引在什么场景下使用会发生失效？原因是什么？"><a href="#9-MySQL-索引在什么场景下使用会发生失效？原因是什么？" class="headerlink" title="9. MySQL 索引在什么场景下使用会发生失效？原因是什么？"></a>9. MySQL 索引在什么场景下使用会发生失效？原因是什么？</h1><h1 id="10-MySQL-MVCC"><a href="#10-MySQL-MVCC" class="headerlink" title="10. MySQL MVCC"></a>10. MySQL MVCC</h1><h1 id="11-MySQL-一张表-没有主键，但是有一列聚集索引，底层是怎么样？"><a href="#11-MySQL-一张表-没有主键，但是有一列聚集索引，底层是怎么样？" class="headerlink" title="11. MySQL 一张表 没有主键，但是有一列聚集索引，底层是怎么样？"></a>11. MySQL 一张表 没有主键，但是有一列聚集索引，底层是怎么样？</h1><pre><code>延伸: 如果是非InnoDB存储引擎，是怎么实现的。
</code></pre>
        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2018/12/02/两阶段提交2PC/">（七）两阶段提交2PC</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="https://wxzhongwang.github.io/page/5/index.html">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2018-12-02T04:30:00.000Z" itemprop="datePublished">2018-12-02</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/分布式事务/">分布式事务</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h1 id="两阶段提交2PC"><a href="#两阶段提交2PC" class="headerlink" title="两阶段提交2PC"></a>两阶段提交2PC</h1><p>当应用逐渐扩展，出现一个应用使用多个数据源的情况，这个时候本地事务已经无法满足数据一致性的要求。由于多个数据源的同时访问，事务需要跨多个数据源管理，分布式事务应运而生。其中最流行的就是两阶段提交（2PC），分布式事务由事务管理器（TM）统一管理。</p>
<p>两阶段提交分为准备阶段和提交阶段。</p>
<h2 id="两阶段提交-commit"><a href="#两阶段提交-commit" class="headerlink" title="两阶段提交-commit"></a>两阶段提交-commit</h2><p><img src="https://mmbiz.qpic.cn/mmbiz_png/Baq5lYpIw7UAmRmz9SHwLAkkzYRj8FzeUN50QbiarIoDfZSgLKjbgwuQ68PUcWBicrYrELotBJpZKKsxfialIyyvw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="image"></p>
<h2 id="两阶段提交-rollback"><a href="#两阶段提交-rollback" class="headerlink" title="两阶段提交-rollback"></a>两阶段提交-rollback</h2><p><img src="https://mmbiz.qpic.cn/mmbiz_png/Baq5lYpIw7UAmRmz9SHwLAkkzYRj8FzeTeCibYLNibQW4CmBvPPejjyR39W2vF2UdTF5o50Qb0rJbW2YwvCWJPJw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="image"></p>
<blockquote>
<p>然而两阶段提交也不能完全保证数据一致性问题，并且有==同步阻塞==的问题，所以其优化版本三阶段提交（3PC）被发明了出来。</p>
</blockquote>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2018/12/02/三阶段提交3PC/">（八）三阶段提交3PC</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="https://wxzhongwang.github.io/page/5/index.html">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2018-12-02T04:30:00.000Z" itemprop="datePublished">2018-12-02</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/分布式事务/">分布式事务</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h1 id="三阶段提交3PC"><a href="#三阶段提交3PC" class="headerlink" title="三阶段提交3PC"></a>三阶段提交3PC</h1><blockquote>
<p>3PC也只能保证绝大多数情况下的数据一致性</p>
</blockquote>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/Baq5lYpIw7UAmRmz9SHwLAkkzYRj8Fze4Qp8szvXcnwialHTwHoLKHvoYQCfWcF2gEWDKM4gibFxfIve5qNx15mQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="image"></p>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2018/12/02/windows 搭建consul/">windows 搭建consul</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="https://wxzhongwang.github.io/page/5/index.html">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2018-12-02T04:30:00.000Z" itemprop="datePublished">2018-12-02</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/SpringCloud/">SpringCloud</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h1 id="windows-搭建consul"><a href="#windows-搭建consul" class="headerlink" title="windows 搭建consul"></a>windows 搭建consul</h1><p><a href="https://blog.csdn.net/qq_19663899/article/details/83341881" target="_blank" rel="noopener">windows 搭建consul</a></p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">cmd 命令窗口执行：consul agent -dev</span><br><span class="line"></span><br><span class="line">consul 自带 UI 界面，打开网址：http:<span class="regexp">//</span>localhost:<span class="number">8500</span> ，可以看到当前注册的服务界面</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">创建服务</span><br><span class="line">sc create consul binPath= <span class="string">"C:\consul1.9.0\consul_1.9.0_windows_amd64\consul.exe agent -server -ui -bootstrap -client 0.0.0.0 -data-dir="</span>C:\consul1.<span class="number">9.0</span>\data-di<span class="string">r" -bind 172.16.129.139"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">consul.exe agent -server -ui -bootstrap -client <span class="number">0.0</span>.<span class="number">0.0</span> -data-dir=<span class="string">"C:\consul1.9.0\data-dir"</span> -bind <span class="number">172.16</span>.xx.<span class="number">139</span></span><br></pre></td></tr></table></figure>
        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2018/12/02/tomcat最大线程数的设置/">tomcat最大线程数的设置</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="https://wxzhongwang.github.io/page/5/index.html">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2018-12-02T04:30:00.000Z" itemprop="datePublished">2018-12-02</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/Java/">Java</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h1 id="tomcat最大线程数的设置"><a href="#tomcat最大线程数的设置" class="headerlink" title="tomcat最大线程数的设置"></a>tomcat最大线程数的设置</h1><p>Tomcat的server.xml中连接器设置如下</p>
<h2 id="1-Tomcat配置"><a href="#1-Tomcat配置" class="headerlink" title="1.Tomcat配置"></a>1.Tomcat配置</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;Connector <span class="attribute">port</span>=<span class="string">"8080"</span>     </span><br><span class="line">   <span class="attribute">maxThreads</span>=<span class="string">"150"</span> <span class="attribute">minSpareThreads</span>=<span class="string">"25"</span> <span class="attribute">maxSpareThreads</span>=<span class="string">"75"</span>     </span><br><span class="line">   <span class="attribute">enableLookups</span>=<span class="string">"false"</span> <span class="attribute">redirectPort</span>=<span class="string">"8443"</span> <span class="attribute">acceptCount</span>=<span class="string">"100"</span>     </span><br><span class="line">   <span class="attribute">debug</span>=<span class="string">"0"</span> <span class="attribute">connectionTimeout</span>=<span class="string">"20000"</span>      </span><br><span class="line">   <span class="attribute">disableUploadTimeout</span>=<span class="string">"true"</span> /&gt;</span><br></pre></td></tr></table></figure>
<h2 id="2-如何加大tomcat连接数"><a href="#2-如何加大tomcat连接数" class="headerlink" title="2.如何加大tomcat连接数"></a>2.如何加大tomcat连接数</h2><p>在tomcat配置文件server.xml中的<connector>配置中，和连接数相关的参数有：</connector></p>
<ul>
<li>minProcessors：最小空闲连接线程数，用于提高系统处理性能，默认值为10</li>
<li>maxProcessors：最大连接线程数，即：并发处理的最大请求数，默认值为75</li>
<li>acceptCount：允许的最大连接数，应大于等于maxProcessors，默认值为100</li>
<li>enableLookups：是否反查域名，取值为：true或false。为了提高处理能力，应设置为false</li>
<li>connectionTimeout：网络连接超时，单位：毫秒。设置为0表示永不超时，这样设置有隐患的。通常可设置为30000毫秒。</li>
</ul>
<p>其中和最大连接数相关的参数为maxProcessors和acceptCount。如果要加大并发连接数，应同时加大这两个参数。<br>web server允许的最大连接数还受制于操作系统的内核参数设置，通常Windows是2000个左右，Linux是1000个左右。tomcat5中的配置示例：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;Connector <span class="attribute">port</span>=<span class="string">"8080"</span></span><br><span class="line">   <span class="attribute">maxThreads</span>=<span class="string">"150"</span> <span class="attribute">minSpareThreads</span>=<span class="string">"25"</span> <span class="attribute">maxSpareThreads</span>=<span class="string">"75"</span></span><br><span class="line">   <span class="attribute">enableLookups</span>=<span class="string">"false"</span> <span class="attribute">redirectPort</span>=<span class="string">"8443"</span> <span class="attribute">acceptCount</span>=<span class="string">"100"</span></span><br><span class="line">   <span class="attribute">debug</span>=<span class="string">"0"</span> <span class="attribute">connectionTimeout</span>=<span class="string">"20000"</span></span><br><span class="line">   <span class="attribute">disableUploadTimeout</span>=<span class="string">"true"</span> /&gt;</span><br></pre></td></tr></table></figure></p>
<p>对于其他端口的侦听配置，以此类推。</p>
<h2 id="3-tomcat中如何禁止列目录下的文件"><a href="#3-tomcat中如何禁止列目录下的文件" class="headerlink" title="3.tomcat中如何禁止列目录下的文件"></a>3.tomcat中如何禁止列目录下的文件</h2><p>在{tomcat_home}/conf/web.xml中，把listings参数设置成false即可，如下：</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;init-<span class="built_in">param</span>&gt;  </span><br><span class="line">    &lt;<span class="built_in">param</span>-name&gt;listings&lt;/<span class="built_in">param</span>-name&gt;  </span><br><span class="line">    &lt;<span class="built_in">param</span>-<span class="built_in">value</span>&gt;<span class="literal">false</span>&lt;/<span class="built_in">param</span>-<span class="built_in">value</span>&gt;  </span><br><span class="line">&lt;/init-<span class="built_in">param</span>&gt;</span><br></pre></td></tr></table></figure>
<h2 id="4-如何加大tomcat可以使用的内存"><a href="#4-如何加大tomcat可以使用的内存" class="headerlink" title="4.如何加大tomcat可以使用的内存"></a>4.如何加大tomcat可以使用的内存</h2><p>tomcat默认可以使用的内存为128MB，在较大型的应用项目中，这点内存是不够的，需要调大。<br>Unix下，在文件{tomcat_home}/bin/catalina.sh的前面，增加如下设置：<br>JAVA_OPTS=’-Xms【初始化内存大小】 -Xmx【可以使用的最大内存】’<br>需要把这个两个参数值调大。例如：<br>JAVA_OPTS=’-Xms256m -Xmx512m’<br>表示初始化内存为256MB，可以使用的最大内存为512MB</p>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2018/12/02/XA协议 /">（六）XA协议</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="https://wxzhongwang.github.io/page/5/index.html">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2018-12-02T04:30:00.000Z" itemprop="datePublished">2018-12-02</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/分布式事务/">分布式事务</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h1 id="XA协议"><a href="#XA协议" class="headerlink" title="XA协议"></a>XA协议</h1><p>XA是由X/Open组织提出的分布式事务的规范。 XA规范主要定义了(全局)事务管理器(TM)和(局 部)资源管理器(RM)之间的接口。主流的关系型数据库产品都是实现了XA接口的。XA 的全称是 <code>eXtended Architecture</code>，它是一个分布式事务协议，通过二阶段提交协议保证强一致性。</p>
<p>XA 规范中定义了分布式事务处理模型，这个模型中包含四个核心角色：</p>
<ul>
<li>RM (Resource Managers)：</li>
</ul>
<p>资源管理器，提供数据资源的操作、管理接口，保证数据的一致性和完整性。最有代表性的就是数据库管理系统，当然有的文件系统、MQ 系统也可以看作 RM。</p>
<ul>
<li>TM (Transaction Managers)：</li>
</ul>
<p>事务管理器，是一个协调者的角色，协调跨库事务关联的所有RM的行为。</p>
<ul>
<li>AP (Application Program)：</li>
</ul>
<p>应用程序，按照业务规则调用RM接口来完成对业务模型数据的变更，当数据的变更涉及多个RM且要保证事务时，AP就会通过TM来定义事务的边界，TM负责协调参与事务的各个RM一同完成一个全局事务。</p>
<ul>
<li>CRMs (Communication Resource Managers)：</li>
</ul>
<p>主要用来进行跨服务的事务的传播。</p>
<blockquote>
<p>XA 不能自动提交</p>
</blockquote>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2018/12/02/缓存雪崩、缓存穿透、缓存预热、缓存更新、缓存降级/">缓存雪崩、缓存穿透、缓存预热、缓存更新、缓存降级</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="https://wxzhongwang.github.io/page/5/index.html">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2018-12-02T04:30:00.000Z" itemprop="datePublished">2018-12-02</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/Redis/">Redis</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h1 id="缓存雪崩、缓存穿透、缓存预热、缓存更新、缓存降级"><a href="#缓存雪崩、缓存穿透、缓存预热、缓存更新、缓存降级" class="headerlink" title="缓存雪崩、缓存穿透、缓存预热、缓存更新、缓存降级"></a>缓存雪崩、缓存穿透、缓存预热、缓存更新、缓存降级</h1><p><a href="https://www.cnblogs.com/leeSmall/p/8594542.html" target="_blank" rel="noopener">参考</a> </p>
<h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p>缓存雪崩我们可以简单的理解为：由于原有缓存失效，新缓存未到期间(例如：我们设置缓存时采用了相同的过期时间，在同一时刻出现大面积的缓存过期)，所有原本应该访问缓存的请求都去查询数据库了，而对数据库CPU和内存造成巨大压力，严重的会造成数据库宕机。从而形成一系列连锁反应，造成整个系统崩溃。</p>
<p>缓存正常从Redis中获取，示意图如下：</p>
<p><img src="http://p1.pstatp.com/large/pgc-image/1521269040783ad8b0b3415" alt="image"></p>
<p>缓存失效瞬间示意图如下：</p>
<p><img src="http://p3.pstatp.com/large/pgc-image/15212690408812aad2545bb" alt="image"></p>
<p>解决方案:</p>
<p>（1）碰到这种情况，一般并发量不是特别多的时候，使用最多的解决方案是加锁排队，伪代码如下：<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public Object getProductListNew()&#123;</span><br><span class="line">    int <span class="keyword">cacheTime </span>= <span class="number">30</span><span class="comment">;</span></span><br><span class="line">    String <span class="keyword">cacheKey </span>= <span class="string">"product_list"</span><span class="comment">;</span></span><br><span class="line">    String localKey = <span class="keyword">cacheKey;</span></span><br><span class="line"><span class="keyword"> </span>   </span><br><span class="line">    String <span class="keyword">cacheValue </span>= <span class="keyword">CacheHelper.get(cacheKey);</span></span><br><span class="line"><span class="keyword"> </span>   if(<span class="keyword">cacheValue </span>!= null)&#123;</span><br><span class="line">        return <span class="keyword">cacheValue;</span></span><br><span class="line"><span class="keyword"> </span>   &#125; else &#123;</span><br><span class="line">        sychronized(localKey)&#123;</span><br><span class="line">            if(<span class="keyword">cacheValue </span>!= null)&#123;</span><br><span class="line">                 return <span class="keyword">cacheValue;</span></span><br><span class="line"><span class="keyword"> </span>           &#125; else  &#123;</span><br><span class="line">                <span class="keyword">cacheValue </span>= getProductListFromDB()<span class="comment">;</span></span><br><span class="line">                <span class="keyword">CacheHelper.add(cacheKey, </span><span class="keyword">cacheValue, </span><span class="keyword">cacheTime);</span></span><br><span class="line"><span class="keyword"> </span>           &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        return <span class="keyword">cacheValue;</span></span><br><span class="line"><span class="keyword"> </span>   &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>加锁排队只是为了减轻数据库的压力，并没有提高系统吞吐量。假设在高并发下，缓存重建期间key是锁着的，这是过来1000个请求999个都在阻塞的。同样会导致用户等待超时，这是个治标不治本的方法！</p>
<p>注意：加锁排队的解决方式分布式环境的并发问题，有可能还要解决分布式锁的问题；线程还会被阻塞，用户体验很差！因此，在真正的高并发场景下很少使用！</p>
<p>（2）给每一个缓存数据增加相应的缓存标记，记录缓存的是否失效，如果缓存标记失效，则更新数据缓存，实例伪代码如下：</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">Object</span> getProductListNew()&#123;</span><br><span class="line">    <span class="built_in">int</span> cacheTime = <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">String</span> cacheKey = <span class="string">"product_list"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//缓存标记 </span></span><br><span class="line">    <span class="keyword">String</span> cacheSign = cacheKey + <span class="string">"_sign"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">String</span> sign = CacheHelper.<span class="built_in">get</span>(cacheSign);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">String</span> cacheValue = CacheHelper.<span class="built_in">get</span>(cacheKey);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(sign != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> cacheValue;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//过期 </span></span><br><span class="line">        CacheHelper.<span class="built_in">add</span>(cacheSign, <span class="number">1</span>, cacheTime);</span><br><span class="line">        ThreadPool.QueueUserWorkItem((arg -&gt; &#123;</span><br><span class="line">            cacheValue = getProductListFromDB();</span><br><span class="line">            CacheHelper.<span class="built_in">add</span>(cacheKey, cacheValue, cacheTime * <span class="number">2</span>);</span><br><span class="line">        &#125;));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> cacheValue;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解释说明：</p>
<p>1、缓存标记：记录缓存数据是否过期，如果过期会触发通知另外的线程在后台去更新实际key的缓存；</p>
<p>2、缓存数据：它的过期时间比缓存标记的时间延长1倍，例：标记缓存时间30分钟，数据缓存设置为60分钟。 这样，当缓存标记key过期后，实际缓存还能把旧数据返回给调用端，直到另外的线程在后台更新完成后，才会返回新缓存。</p>
<p>关于缓存崩溃的解决方法，这里提出了三种方案：使用锁或队列、设置过期标志更新缓存、为key设置不同的缓存失效时间，还有一各被称为“二级缓存”的解决方法，有兴趣的读者可以自行研究。</p>
<h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p>缓存穿透是指用户查询数据，在数据库没有，自然在缓存中也不会有。这样就导致用户查询的时候，在缓存中找不到，每次都要去数据库再查询一遍，然后返回空（相当于进行了两次无用的查询）。这样请求就绕过缓存直接查数据库，这也是经常提的缓存命中率问题。</p>
<p> 缓存穿透解决方案：</p>
<p>（1）采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。</p>
<p>（2）如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。通过这个直接设置的默认值存放到缓存，这样第二次到缓存中获取就有值了，而不会继续访问数据库，这种办法最简单粗暴！ 把空结果也给缓存起来，这样下次同样的请求就可以直接返回空了，即可以避免当查询的值为空时引起的缓存穿透。同时也可以单独设置个缓存区域存储空值，对要查询的key进行预先校验，然后再放行给后面的正常缓存处理逻辑。</p>
<h2 id="缓存预热"><a href="#缓存预热" class="headerlink" title="缓存预热"></a>缓存预热</h2><p> 缓存预热就是系统上线后，提前将相关的缓存数据直接加载到缓存系统。避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据！</p>
<p> 缓存预热解决方案：</p>
<ul>
<li><p>（1）直接写个缓存刷新页面，上线时手工操作下；</p>
</li>
<li><p>（2）数据量不大，可以在项目启动的时候自动进行加载；</p>
</li>
<li><p>（3）定时刷新缓存；</p>
</li>
</ul>
<h2 id="缓存更新"><a href="#缓存更新" class="headerlink" title="缓存更新"></a>缓存更新</h2><p>除了缓存服务器自带的缓存失效策略之外（Redis默认的有6中策略可供选择），我们还可以根据具体的业务需求进行自定义的缓存淘汰，常见的策略有两种：</p>
<p>（1）定时去清理过期的缓存；</p>
<p>（2）当有用户请求过来时，再判断这个请求所用到的缓存是否过期，过期的话就去底层系统得到新数据并更新缓存。</p>
<p>两者各有优劣，第一种的缺点是维护大量缓存的key是比较麻烦的，第二种的缺点就是每次用户请求过来都要判断缓存失效，逻辑相对比较复杂！具体用哪种方案，大家可以根据自己的应用场景来权衡。</p>
<h2 id="缓存降级"><a href="#缓存降级" class="headerlink" title="缓存降级"></a>缓存降级</h2><p>当访问量剧增、服务出现问题（如响应时间慢或不响应）或非核心服务影响到核心流程的性能时，仍然需要保证服务还是可用的，即使是有损服务。系统可以根据一些关键数据进行自动降级，也可以配置开关实现人工降级。</p>
<p>降级的最终目的是保证核心服务可用，即使是有损的。而且有些服务是无法降级的（如加入购物车、结算）。</p>
<p>在进行降级之前要对系统进行梳理，看看系统是不是可以丢卒保帅；从而梳理出哪些必须誓死保护，哪些可降级；比如可以参考日志级别设置预案：</p>
<p>（1）一般：比如有些服务偶尔因为网络抖动或者服务正在上线而超时，可以自动降级；</p>
<p>（2）警告：有些服务在一段时间内成功率有波动（如在95~100%之间），可以自动降级或人工降级，并发送告警；</p>
<p>（3）错误：比如可用率低于90%，或者数据库连接池被打爆了，或者访问量突然猛增到系统能承受的最大阀值，此时可以根据情况自动降级或者人工降级；</p>
<p>（4）严重错误：比如因为特殊原因数据错误了，此时需要紧急人工降级。</p>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2018/12/02/事务的隔离级别/">事务的隔离级别</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="https://wxzhongwang.github.io/page/5/index.html">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2018-12-02T04:30:00.000Z" itemprop="datePublished">2018-12-02</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/分布式事务/">分布式事务</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h1 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h1><h2 id="为何需要设置数据库隔离级别？"><a href="#为何需要设置数据库隔离级别？" class="headerlink" title="为何需要设置数据库隔离级别？"></a>为何需要设置数据库隔离级别？</h2><p>在数据库操作中，在并发的情况下可能出现如下问题：</p>
<ul>
<li>更新丢失（Lost Update）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">不论后面的数据库更新是否提交，都有可能让前面的更新丢失。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>如果多个线程操作，基于同一个查询结构对表中的记录进行修改，那么后修改的记录将会覆盖前面修改的记录，前面的修改就丢失掉了，这就叫做更新丢失。这是因为系统没有执行任何的锁操作，因此并发事务并没有被隔离开来。 </p>
<blockquote>
<p>第 1 类丢失更新：事务A撤销时，把已经提交的事务B的更新数据覆盖了。 </p>
</blockquote>
<table>
<thead>
<tr>
<th>时间</th>
<th>取款事务A</th>
<th>取款事务B</th>
</tr>
</thead>
<tbody>
<tr>
<td>T1</td>
<td>开始事务</td>
<td></td>
</tr>
<tr>
<td>T2</td>
<td></td>
<td>开始事务</td>
</tr>
<tr>
<td>T3</td>
<td>查询余额为1000元</td>
<td></td>
</tr>
<tr>
<td>T4</td>
<td></td>
<td>查询余额为1000元</td>
</tr>
<tr>
<td>T5</td>
<td></td>
<td>汇入100元，修改余额为1100元</td>
</tr>
<tr>
<td>T6</td>
<td></td>
<td>提交事务</td>
</tr>
<tr>
<td>T7</td>
<td>取款100元， 修改余额为900元</td>
<td></td>
</tr>
<tr>
<td>T8</td>
<td>撤销事务</td>
<td></td>
</tr>
<tr>
<td>T9</td>
<td>余额回复为1000元（丢失更新）</td>
<td></td>
</tr>
</tbody>
</table>
<blockquote>
<p>第 2 类丢失更新：事务A覆盖事务B已经提交的数据，造成事务B所做的操作丢失。</p>
</blockquote>
<table>
<thead>
<tr>
<th>时间</th>
<th>取款事务A</th>
<th>取款事务B</th>
</tr>
</thead>
<tbody>
<tr>
<td>T1</td>
<td></td>
<td>开始事务</td>
</tr>
<tr>
<td>T2</td>
<td>开始事务</td>
<td></td>
</tr>
<tr>
<td>T3</td>
<td></td>
<td>查询余额为1000元</td>
</tr>
<tr>
<td>T4</td>
<td>查询余额为1000元</td>
<td></td>
</tr>
<tr>
<td>T5</td>
<td></td>
<td>取款100元， 修改余额为900元</td>
</tr>
<tr>
<td>T6</td>
<td></td>
<td>提交事务</td>
</tr>
<tr>
<td>T7</td>
<td>汇入100元，修改余额为1100元</td>
<td></td>
</tr>
<tr>
<td>T8</td>
<td>提交事务</td>
<td></td>
</tr>
<tr>
<td>T9</td>
<td>余额回复为1100元（丢失更新）</td>
<td></td>
</tr>
</tbody>
</table>
<blockquote>
<p>解决方法：对行加锁，只允许并发一个更新事务。</p>
</blockquote>
<ul>
<li>脏读（Dirty Read）<blockquote>
<p>脏读（Dirty Read）：A事务读取B事务尚未提交的数据并在此基础上操作，而B事务执行回滚，那么A读取到的数据就是脏数据。</p>
</blockquote>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">读到了别的事务回滚前的脏数据</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>时间</th>
<th>取款事务A</th>
<th>取款事务B</th>
</tr>
</thead>
<tbody>
<tr>
<td>T1</td>
<td></td>
<td>开始事务</td>
</tr>
<tr>
<td>T2</td>
<td>开始事务</td>
<td></td>
</tr>
<tr>
<td>T3</td>
<td></td>
<td>查询余额为1000元</td>
</tr>
<tr>
<td>T4</td>
<td></td>
<td>取出500元，余额为500元</td>
</tr>
<tr>
<td>T5</td>
<td>查询余额为500元 （脏读）</td>
<td></td>
</tr>
<tr>
<td>T6</td>
<td></td>
<td>撤销事务，余额恢复为1000元</td>
</tr>
<tr>
<td>T7</td>
<td>汇入100元，修改余额600元</td>
<td></td>
</tr>
<tr>
<td>T8</td>
<td>提交事务</td>
<td></td>
</tr>
</tbody>
</table>
<blockquote>
<p>解决办法：如果在第一个事务提交前，任何其他事务不可读取其修改过的值，则可以避免该问题。</p>
</blockquote>
<ul>
<li>不可重复读（Non-repeatable Reads） <blockquote>
<p>一个事务对同一行数据重复读取两次，但是却得到了不同的结果。事务T1读取某一数据后，事务T2对其做了修改，当事务T1再次读该数据时得到与前一次不同的值。</p>
</blockquote>
</li>
</ul>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一个事务中两次读取的数据的内容不一致 <span class="comment">(一般基于行而言)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">事务<span class="keyword">A</span>首先读取了一条数据，然后执行逻辑的时候，事务B将这条数据改变了，</span><br><span class="line">然后事务<span class="keyword">A</span>再次读取的时候，发现数据不匹配了，就是不可重复读</span><br><span class="line"></span><br><span class="line">同一数据，在一个事务的两次读取之间存在另一更新、删除的事务。</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>时间</th>
<th>取款事务A</th>
<th>取款事务B</th>
</tr>
</thead>
<tbody>
<tr>
<td>T1</td>
<td></td>
<td>开始事务</td>
</tr>
<tr>
<td>T2</td>
<td>开始事务</td>
<td></td>
</tr>
<tr>
<td>T3</td>
<td></td>
<td>查询余额为1000元</td>
</tr>
<tr>
<td>T4</td>
<td>查询余额为1000元</td>
<td></td>
</tr>
<tr>
<td>T5</td>
<td></td>
<td>取出100元，修改余额为900元</td>
</tr>
<tr>
<td>T6</td>
<td></td>
<td>提交事务</td>
</tr>
<tr>
<td>T7</td>
<td>查询余额为900元（不可重复读）</td>
<td></td>
</tr>
</tbody>
</table>
<blockquote>
<p>解决办法：如果只有在修改事务完全提交之后才可以读取数据，则可以避免该问题。</p>
</blockquote>
<ul>
<li>幻读<blockquote>
<p>指两次执行同一条 select语句会出现不同的结果，第二次读会增加一数据行，并没有说这两次执行是在同一个事务中。一般情况下，幻象读应该正是我们所需要的。但有时候却不是，如果打开的游标，在对游标进行操作时，并不希望新增的记录加到游标命中的数据集中来。隔离级别为游标稳定性的，可以阻止幻象读。例如：目前工资为1000的员工有10人。那么事务1中读取所有工资为1000的员工，得到了10条记录；这时事务2向员工表插入了一条员工记录，工资也为1000；那么事务1再次读取所有工资为1000的员工共读取到了11条记录。 </p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一个事务中两次读取的数据的数量不一致 <span class="comment">(一般基于表而言)</span></span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">事务<span class="keyword">A</span>首先根据条件索引得到N条数据，</span><br><span class="line">然后事务B改变了这N条数据之外的M条或者增添了M条符合事务<span class="keyword">A</span>搜索条件的数据，</span><br><span class="line">导致事务<span class="keyword">A</span>再次搜索发现有N+M条数据了，就产生了幻读。</span><br><span class="line"></span><br><span class="line">同一数据，在一个事务中的两次（读取）写入之间存在另一插入的事务。</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>时间</th>
<th>统计金额事务A</th>
<th>转账事务B</th>
</tr>
</thead>
<tbody>
<tr>
<td>T1</td>
<td></td>
<td>开始事务</td>
</tr>
<tr>
<td>T2</td>
<td>开始事务</td>
<td></td>
</tr>
<tr>
<td>T3</td>
<td>统计总存款为10000元</td>
<td></td>
</tr>
<tr>
<td>T4</td>
<td></td>
<td>新增一个存款账户转入100元</td>
</tr>
<tr>
<td>T5</td>
<td></td>
<td>提交事务</td>
</tr>
<tr>
<td>T7</td>
<td>再次统计总存款为10100元</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="不可重复读和幻读比较："><a href="#不可重复读和幻读比较：" class="headerlink" title="不可重复读和幻读比较："></a>不可重复读和幻读比较：</h3><blockquote>
<p>两者有些相似，但是前者针对的是update或delete，后者针对的insert。</p>
</blockquote>
<h2 id="隔离级别包括哪些？"><a href="#隔离级别包括哪些？" class="headerlink" title="隔离级别包括哪些？"></a>隔离级别包括哪些？</h2><p>数据库事务的隔离级别有4个，由低到高依次为</p>
<ul>
<li>Read uncommitted   (未提交读 ==》 读未提交)</li>
</ul>
<p>如果一个事务已经开始写数据，则另外一个事务则不允许同时进行写操作，但允许其他事务读此行数据。该隔离级别可以通过 <strong>排他写锁</strong> 实现。这样就避免了更新丢失，却可能出现脏读。也就是说事务B读取到了事务A未提交的数据。</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">通俗来说就是，事务A开始写，事务<span class="keyword">B不能写，只能读。可能出现脏读。</span></span><br><span class="line"><span class="keyword">（读到未提交的数据）</span></span><br></pre></td></tr></table></figure>
<ul>
<li>Read committed    （提交读 ==》 读已提交）</li>
</ul>
<p>读取数据的事务允许其他事务继续访问该行数据，但是未提交的写事务将会禁止其他事务访问该行。该隔离级别避免了脏读，但是却可能出现不可重复读。事务A事先读取了数据，事务B紧接了更新了数据，并提交了事务，而事务A再次读取该数据时，数据已经发生了改变。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">通俗来讲就是，读数据都可以，一旦有事务开始写，会禁止其他事务访问该行。</span><br><span class="line">避免脏读，可能出现不可重复读。</span><br><span class="line">（同一事务读取一行数据，两次结果不一致，后面一次读取时，数据已经发生改变）</span><br></pre></td></tr></table></figure>
<ul>
<li>Repeatable read   （可重复读）</li>
</ul>
<p>可重复读是指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。那么，在第一个事务中的两次读数据之间，即使第二个事务对数据进行修改，第一个事务两次读到的的数据是一样的。这样就发生了在一个事务内两次读到的数据是一样的，因此称为是可重复读。读取数据的事务将会禁止写事务（但允许读事务），写事务则禁止任何其他事务。这样避免了不可重复读取和脏读，但是有时可能出现幻象读。（读取数据的事务）这可以通过“共享读锁”和“排他写锁”实现。</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">在一个事务内，多次读同一数据。在事务未提交前，另一事务也在访问同一数据，</span><br><span class="line">在第一个事务两次读之间，即使第二个事务修改数据，第一个数据的两次读到的数据仍然是一致的。</span><br><span class="line"></span><br><span class="line">避免了不可重复读和脏读。</span><br><span class="line"></span><br><span class="line">读事务，禁止写（允许读事务）。</span><br><span class="line">写事务，禁止任何其他事务。</span><br><span class="line"></span><br><span class="line">可能出现幻读 eg：</span><br><span class="line"><span class="number">1.</span> 先更新某一列为从‘<span class="number">1</span>’更新为‘<span class="number">2</span>’ </span><br><span class="line"><span class="number">2.</span> 插入一行，该里值仍未‘<span class="number">1</span>’</span><br><span class="line"><span class="number">3.</span> 再次读取仍读到列值为‘<span class="number">1</span>’的数据</span><br></pre></td></tr></table></figure>
<ul>
<li>Serializable      （串行化）</li>
</ul>
<p>提供严格的事务隔离。它要求事务序列化执行，事务只能一个接着一个地执行，但不能并发执行。如果仅仅通过“行级锁”是无法实现事务序列化的，必须通过其他机制保证新插入的数据不会被刚执行查询操作的事务访问到。序列化是最高的事务隔离级别，同时代价也花费最高，性能很低，一般很少使用，在该级别下，事务顺序执行，不仅可以避免脏读、不可重复读，还避免了幻像读。</p>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
<th>第一类丢失更新</th>
<th>第二类丢失更新</th>
</tr>
</thead>
<tbody>
<tr>
<td>读未提交</td>
<td>允许</td>
<td>允许</td>
<td>允许</td>
<td>不允许</td>
<td>允许 </td>
</tr>
<tr>
<td>读已提交</td>
<td>不允许</td>
<td>允许</td>
<td>允许</td>
<td>不允许</td>
<td>允许</td>
</tr>
<tr>
<td>可重复读</td>
<td>不允许</td>
<td>不允许</td>
<td>允许</td>
<td>不允许</td>
<td>不允许</td>
</tr>
<tr>
<td>串行化</td>
<td>不允许</td>
<td>不允许</td>
<td>不允许</td>
<td>不允许</td>
<td>不允许</td>
</tr>
</tbody>
</table>

        
    </section>
</article>




<nav class="page-nav">
    <a class="extend prev" rel="prev" href="/page/4/">&laquo; 上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><span class="space">&hellip;</span><a class="page-number" href="/page/23/">23</a><a class="extend next" rel="next" href="/page/6/">下一页 &raquo;</a>
</nav>


</div>
        <footer class="footer">
    Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, Theme by <a href="https://github.com/sanonz/hexo-theme-concise" target="_blank">Concise</a>

    
    <script>
        var _hmt = _hmt || [];
        (function () {
            var hm = document.createElement("script");
            hm.src = "https://hm.baidu.com/hm.js?e4027971a230b210f4671f485b33846a";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();
    </script>
    
</footer>

    </main>

    <script type="text/javascript" src="https://cdn.bootcss.com/jquery/1.9.0/jquery.min.js"></script>
    <script type="text/javascript">
    $(function() {
        var nodes = {
            nav: $('#nav'),
            aside: $('#aside'),
            asideInner: $('#aside-inner'),
            navInner: $('#nav-inner')
        };

        var doing = false;
        nodes.asideInner.on('webkitAnimationEnd mozAnimationEnd oAnimationEnd oanimationend animationend', function() {
            if (nodes.aside.hasClass('mobile-open')) {
                nodes.aside.removeClass('mobile-open');
            } else {
                nodes.aside.removeClass('mobile-close panel-show');
            }
            doing = false;
        });
        $('#open-panel, #aside-mask').on('click', function() {
            if (doing) {
                return;
            }
            
            if (nodes.aside.hasClass('panel-show')) {
                nodes.aside.addClass('mobile-close');
            } else {
                nodes.aside.addClass('mobile-open panel-show');
            }
        });
        $('#open-menus').on('click', function() {
            nodes.navInner.slideToggle();
        });

        if (window.innerWidth <= 960) {
            setTimeout(function() {
                nodes.navInner.slideUp();
            }, 3000);
        }
    });
    </script>
    

</body>
</html>
