<!DOCTYPE html>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="UTF-8">

    

    

    <title>我喜欢你喜欢我的歌</title>
    <meta name="author" content="Dick Zhong">
    <meta name="version" content="1.0.0">
    <meta name="keywords" content>
    <meta name="description" content>
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">

    
    <link rel="alternate" href="/atom.xml" title="我喜欢你喜欢我的歌" type="application/atom+xml">
    
    
    <link rel="icon" href="/images/favicon.ico">
    

    <link rel="stylesheet" href="/css/style.css">
</head>
<body>

    <main class="app">
        <header class="header clearfix">
    <div id="nav" class="nav">
    <div class="nav-mobile">
        <button id="open-panel" class="open-panel nav-mobile-item"><i class="icon-documents"></i></button>
        <h1 class="nav-mobile-title nav-mobile-item">我喜欢你喜欢我的歌</h1>
        <button id="open-menus" class="open-panel nav-mobile-item"><i class="icon-library"></i></button>
    </div>

    <nav id="nav-inner" class="nav-inner">
        
            <a class="nav-item active" href="/">
                <span class="nav-text">首页</span>
            </a>
        
            <a class="nav-item" href="/categories/">
                <span class="nav-text">分类</span>
            </a>
        
            <a class="nav-item" href="/tags">
                <span class="nav-text">标签</span>
            </a>
        
            <a class="nav-item" href="/archives">
                <span class="nav-text">归档</span>
            </a>
        
            <a class="nav-item" href="/atom.xml">
                <span class="nav-text">订阅</span>
            </a>
        
            <a class="nav-item" href="/about">
                <span class="nav-text">关于</span>
            </a>
        
    </nav>
</div>

    <aside id="aside" class="aside">
    <div id="aside-mask" class="aside-mask"></div>
    <div id="aside-inner" class="aside-inner">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit"><i class="icon-search-stroke"></i></button><input type="hidden" name="sitesearch" value="https://wxzhongwang.github.io"></form>

        
        

        
        <div class="author-meta">
            
            <div class="author-avatar">
                <a href="/">
                    <img src="/images/27359059.jpg" title="咸鱼有点咸">
                </a>
            </div>
            
            <div class="author-name">咸鱼有点咸</div>
            <div class="author-work">Developer</div>
            <div class="author-location">
                <i class="icon-location vm"></i>
                <span class="vm">Hangzhou, China</span>
            </div>
            
            <div class="author-thread-wrap">
                <div class="author-threads clearfix">
                    
                        <a class="thread-item" href="https://github.com/wxzhongwang" target="_blank" rel="noopener">
                            <!-- Generated by IcoMoon.io -->
<svg viewbox="0 0 1024 1024" width="38" height="38" fill="currentColor">
<path d="M512 32.12c-265.004 0-479.88 220.23-479.88 492.090 0 217.446 137.536 401.684 328.202 466.81 23.994 4.498 32.778-10.712 32.778-23.78 0-11.782-0.428-42.632-0.642-83.764-133.466 29.778-161.744-65.984-161.744-65.984-21.852-56.772-53.344-71.982-53.344-71.982-43.49-30.636 3.214-29.992 3.214-29.992 48.202 3.428 73.482 50.772 73.482 50.772 42.846 75.196 112.258 53.558 139.68 40.918 4.284-31.706 16.71-53.558 30.42-65.77-106.474-12.426-218.516-54.63-218.516-243.152 0-53.772 18.638-97.69 49.274-131.966-4.928-12.426-21.424-62.556 4.714-130.252 0 0 40.276-13.282 131.966 50.344 38.348-10.926 79.266-16.282 120.184-16.496 40.704 0.214 81.836 5.57 120.184 16.496 91.692-63.626 131.752-50.344 131.752-50.344 26.136 67.698 9.64 117.828 4.714 130.252 30.636 34.492 49.274 78.408 49.274 131.966 0 188.952-112.258 230.514-219.16 242.724 17.138 15.21 32.564 45.202 32.564 91.048 0 65.77-0.642 118.898-0.642 134.966 0 13.068 8.57 28.492 32.992 23.566 191.094-64.912 328.418-249.152 328.418-466.382 0-271.86-214.874-492.090-479.88-492.090z"/>
</svg>

                        </a>
                    
                        <a class="thread-item" href="https://weibo.com/u/6558527999" target="_blank" rel="noopener">
                            <!-- Generated by IcoMoon.io -->
<svg viewbox="0 0 1024 1024" width="38" height="38" fill="currentColor">
<path d="M21.332 512c0-270.988 219.68-490.666 490.668-490.666s490.666 219.68 490.666 490.666c0 270.988-219.678 490.666-490.666 490.666s-490.666-219.678-490.666-490.666zM960 512c0-247.424-200.576-448-448-448s-448 200.576-448 448c0 247.424 200.576 448 448 448s448-200.576 448-448zM768 597.332c47.128 0 85.332-38.206 85.332-85.332s-38.206-85.332-85.332-85.332c-47.128 0-85.332 38.204-85.332 85.332s38.206 85.332 85.332 85.332zM512 597.332c47.128 0 85.332-38.206 85.332-85.332s-38.206-85.332-85.332-85.332c-47.128 0-85.332 38.204-85.332 85.332s38.204 85.332 85.332 85.332zM255.998 597.332c47.128 0 85.332-38.206 85.332-85.332s-38.204-85.332-85.332-85.332c-47.128 0-85.332 38.204-85.332 85.332s38.204 85.332 85.332 85.332z"/>
</svg>

                        </a>
                    
                        <a class="thread-item" href="https://twitter.com/wxzhongwang" target="_blank" rel="noopener">
                            <!-- Generated by IcoMoon.io -->
<svg viewbox="0 0 1024 1024" width="38" height="38" fill="currentColor">
<path d="M512.029 31.011c-263.32 0-476.784 213.502-476.784 476.784 0 263.32 213.464 476.743 476.784 476.743s476.743-213.424 476.743-476.743c0-263.282-213.444-476.784-476.743-476.784zM752.193 411.663c0.251 5.151 0.349 10.319 0.349 15.548 0 158.786-120.856 341.85-341.85 341.85-67.844 0-131.021-19.884-184.188-53.961 9.41 1.104 18.955 1.665 28.656 1.665 56.305 0 108.115-19.208 149.221-51.425-52.567-0.987-96.925-35.741-112.22-83.468 7.32 1.433 14.85 2.149 22.595 2.149 10.959 0 21.569-1.433 31.656-4.201-54.987-11.035-96.402-59.634-96.402-117.796 0-0.524 0-1.025 0.020-1.549 16.186 9.003 34.716 14.404 54.427 15.044-32.258-21.587-53.458-58.317-53.458-100.023 0-22.015 5.925-42.673 16.264-60.408 59.266 72.683 147.807 120.527 247.676 125.521-2.053-8.77-3.118-17.968-3.118-27.378 0-66.333 53.787-120.14 120.158-120.14 34.561 0 65.771 14.599 87.69 37.93 27.378-5.363 53.091-15.393 76.305-29.16-9.003 28.074-28.036 51.618-52.858 66.47 24.338-2.903 47.495-9.37 69.024-18.917-16.070 24.144-36.459 45.306-59.945 62.248z"/>
</svg>

                        </a>
                    
                </div>
            </div>
            
        </div>
        
    </div>
</aside>

</header>

        <div id="content" class="content">
    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2018/10/01/JVM课程七/">JVM课程七</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="https://wxzhongwang.github.io/page/4/index.html">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2018-10-01T14:22:22.000Z" itemprop="datePublished">2018-10-01</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/JVM/">JVM</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h2 id="分代收集器"><a href="#分代收集器" class="headerlink" title="分代收集器"></a>分代收集器</h2><p>一起七个 3 + 3 + 1</p>
<p>在收集器使用的时候都是：新老搭配的。</p>
<p>新生代收集器：</p>
<ul>
<li>Serial</li>
<li>ParNew</li>
<li>Parallel Scavenge</li>
</ul>
<p>老年代收集器：</p>
<ul>
<li>CMS(Concurrent Mark Sweep)</li>
<li>Serial Old </li>
<li>Parallel Old</li>
</ul>
<p>新老通吃：<br>G1: Garbadge First</p>
<h2 id="新生代收集器"><a href="#新生代收集器" class="headerlink" title="新生代收集器"></a>新生代收集器</h2><h3 id="Serial-GC-串行"><a href="#Serial-GC-串行" class="headerlink" title="Serial GC(串行)"></a>Serial GC(串行)</h3><p>HotSpot运行在client模式下的默认新生代收集器。只用一个CPU/一个收集器线程去完成GC。<br>“Stop The World” -XX:+UseSerialGC</p>
<ol>
<li>启动回收</li>
<li>暂停其他所有工作线程。新生代回收采用<strong>复制</strong>算法。</li>
<li>暂停其他所有工作线程。老年代回收采用<strong>标记整理算法</strong>。单线程收集，但是简单高效。<br>在内存占用不大的应用中，效率很高。</li>
</ol>
<h3 id="ParNew-并行"><a href="#ParNew-并行" class="headerlink" title="ParNew(并行)"></a>ParNew(并行)</h3><p>其本质是Serial的多线程版本，目的是缩短垃圾收集的时间，也就是占用工作线程时间的问题。单CPU甚至不如Serial，但是在多核CPU配合多线程效果明显。多核CPU + 超线程技术。<br>若VM启用老年代使用CMS(concurrent mark sweep)时候，<br>参数： -XX:+UseConcMarkSweepGC<br>新生代次收集器默认为ParNew。<br>多核CPU时候一般配置为CPU核数。-XX:ParallelGCThreads=<n> 参数控制GC线程数。</n></p>
<ol>
<li>启动回收</li>
<li>暂停其他所有工作线程。新生代回收采用<strong>复制</strong>算法。 (GC线程多个同时工作，并行执行)</li>
<li>暂停其他所有工作线程。老年代回收采用<strong>标记整理算法</strong>。</li>
</ol>
<h3 id="Parallel-Scavenge"><a href="#Parallel-Scavenge" class="headerlink" title="Parallel Scavenge"></a>Parallel Scavenge</h3><p>并行多线程，复制算法。关注点与ParNew不同，关注的是系统吞吐量。</p>
<p>系统吞吐量 = 运行用户代码时间 /（运行用户代码时间 + 垃圾回收时间）</p>
<p>停顿时间越短就越适用于用户交互的程序。良好的响应速度提升用户体验。<br>而高吞吐则适用于后台计算而不需要太多交互的任务，可以最高效率的利用CPU时间，<br>尽快的完成程序的运算任务。</p>
<h2 id="老年代收集器"><a href="#老年代收集器" class="headerlink" title="老年代收集器"></a>老年代收集器</h2><h3 id="Serial-Old"><a href="#Serial-Old" class="headerlink" title="Serial Old"></a>Serial Old</h3><ol>
<li>启动回收</li>
<li>暂停其他所有工作线程。新生代回收采用复制算法。</li>
<li>暂停其他所有工作线程。老年代回收采用标记整理算法。单线程收集，但是简单高效。<br>在内存占用不大的应用中，效率很高。</li>
</ol>
<p>可以与任意的新生代收集器配置使用</p>
<h3 id="Parallel-Old"><a href="#Parallel-Old" class="headerlink" title="Parallel Old"></a>Parallel Old</h3><p>只能配合Parallel Scavenge收集器一起使用。</p>
<h3 id="CMS-并发"><a href="#CMS-并发" class="headerlink" title="CMS (并发)"></a>CMS (并发)</h3><p>Concurrent Mark Sweep,可以和用户线程同时工作。是一款并发收集器。<br>虽然有理论上表现更好的G1收集器，主流的仍然是CMS收集器。<br>能用于server模式下的JVM优化。能结合新生代的Serial 和 ParNew一起使用。</p>
<h2 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h2><p>Garbage-First。可以运用在新生代和老年代的直接分区收集。面向服务端的垃圾收集器。 –XX:+UseG1GC<br>将Java堆划分为多个相等的独立区域Region，保留新生代和老年代的概念。但是不再是物理隔离。</p>
<p>优化方式：<br>1.选择JVM版本<br>2.对于堆区大小的分配<br>3.垃圾回收的方式</p>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2018/09/20/JVM课程八/">JVM课程八</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="https://wxzhongwang.github.io/page/4/index.html">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2018-09-20T06:55:00.000Z" itemprop="datePublished">2018-09-20</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/JVM/">JVM</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h1 id="JVM性能监测工具"><a href="#JVM性能监测工具" class="headerlink" title="JVM性能监测工具"></a>JVM性能监测工具</h1><p><strong>jps</strong><br>      查询运行于jvm的线程jps -l</p>
<p><strong>jstat</strong><br>        查看HotSpot VM运行的信息<br>        jstat -gc pid 毫秒数 次数</p>
<pre><code>From Created
From Used
To Created 
To Used
Eden Created
Eden Used
Old Created
Old Used
Permanent Created
Permanent Used
Young GC 次收集器收集次数
Young GC Time 次收集器时间
Full GC  全收集次数
Full GC Time 全收集时间
GC Time 收集总时间
S0C S1C S0U S1U EC EU OC OU PC PU YGC YGCT FGC FGCT GCT
</code></pre><p><strong>jvisualvm</strong><br>        可视化工具<br>        jvisualvm</p>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2018/09/15/JVM课程六/">JVM课程六</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="https://wxzhongwang.github.io/page/4/index.html">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2018-09-15T15:12:00.000Z" itemprop="datePublished">2018-09-15</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/JVM/">JVM</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h1 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h1><p>Scavenge(次收集) 和 Full GC(全收集)区别</p>
<p>新生代GC (Scavenge GC): 发生在新生代的GC，因为新生代的Java对象大多是朝生夕死，所以Scavenge GC非常频繁。<br>回收速度快，当Eden内存空间不足时，会触发Scavenge GC。<br>一般情况下，当新对象生成时，并且在Eden中申请空间失败，就会触发Scavenge GC,对Eden区进行GC，清除非存活对象，<br>将尚存活的对象移动至Survivor区，然后整理两个Survivor区，这种方式的GC是对年轻代的Eden区进行，不会影响老年代。</p>
<p>老年代GC (Full GC/Major GC): Full GC是指发生在老年代的GC。出现了Full GC一般至少会伴随一次Minor GC。<br>老年代的对象大多是Minor GC过程中从新生代进入老年代。比如分配担保失败。Full GC的速度一般会比Minor GC慢十倍以上。<br>当老年代内存不足时或者显式调用System.gc()时候，会触发Full GC。</p>
<p>次收集：<br>当年轻代堆空间紧张会被触发，相对于全收集，收集间隔较短。</p>
<p>全收集：<br>当老年代或者持久代空间满了时候会触发全收集操作。可以使用System.gc()显式调用。<br>全收集一般会根据堆大小，需要的时间较长。不过全收集时间超过3s-5s,那就太长了。</p>
<p>新生代收集器：<br>Serial<br>ParNew<br>Parallel scavenge </p>
<p>老年代收集器：<br>CMS(Concurrent Mark Sweep)<br>Serial Old<br>Parallel Old </p>
<p>新老通吃：<br>G1: Garbadge First</p>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2018/09/15/JVM课程四/">JVM课程四</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="https://wxzhongwang.github.io/page/4/index.html">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2018-09-15T02:55:00.000Z" itemprop="datePublished">2018-09-15</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/JVM/">JVM</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h1 id="JVM分代策略"><a href="#JVM分代策略" class="headerlink" title="JVM分代策略"></a>JVM分代策略</h1><h2 id="新生代"><a href="#新生代" class="headerlink" title="新生代"></a>新生代</h2><p>三个区的默认存放空间是Eden : From : To = 8: 1: 1</p>
<p>目的是因为HotSpot采用复制算法来回收新生代，设置这个比例是为了充分利用空间。</p>
<p>新生成的对象优先存放在新生代中，在新生代中，常规应用采取一次垃圾收集可以回收70%-90%。</p>
<p>新生成的对象在Eden区中分配（大对象除外，直接老年代）。</p>
<p>当Eden没有足够空间，虚拟机发起一次Minor GC。（只会收集一次Eden区）</p>
<p>GC开始时，对象只会存在于Eden区和From Suvivor区，To Survivor为空。用于复制</p>
<p>GC进行时，Eden区中所有存活的对象会被复制到To Survivor(连续存储)，<br>而在From Survivor区中仍存活的对象，会根据年龄决定去向。<br>阈值为15，每熬过一次GC,年龄就加1，GC分代年龄值存在对象的header中，<br>大于15，移至老年代中，没有达到15的复制到To Survivor。<br>之后，From和To交换角色。From被清空，变成下一次GC的To区， 而To区成为下一次GC的From区。</p>
<p>无论如何，保证To区域在下一轮GC中为空的。</p>
<blockquote>
<p>note: 当TO区域用于复制From中的对象时，出现空间不足的时候，需要依赖老年代分配内存进行存放。</p>
</blockquote>
<h2 id="老年代"><a href="#老年代" class="headerlink" title="老年代"></a>老年代</h2><p>在新生代中经历了多次的GC后存活下来的对象会进入老年代。<br>老年代的对象生命周期较长，存活率比较高，在老年代中进行GC的频率较低，效率也较低。</p>
<h2 id="永久代"><a href="#永久代" class="headerlink" title="永久代"></a>永久代</h2><p>永久代中存放类信息，常量，静态变量，即时编译器编译后的代码等数据。<br>对此区域，Java虚拟机规范指出可以不进行垃圾收集。一般而言不会进行垃圾回收。</p>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2018/09/15/JVM课程五/">JVM课程五</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="https://wxzhongwang.github.io/page/4/index.html">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2018-09-15T02:55:00.000Z" itemprop="datePublished">2018-09-15</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/JVM/">JVM</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h1 id="垃圾回收算法和收集器"><a href="#垃圾回收算法和收集器" class="headerlink" title="垃圾回收算法和收集器"></a>垃圾回收算法和收集器</h1><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="引用计数（reference-counting）"><a href="#引用计数（reference-counting）" class="headerlink" title="引用计数（reference counting）"></a>引用计数（reference counting）</h3><p>古老的算法。此对象有一个引用，增加一个计数，删除一个引用减少一个引用。垃圾回收时，只用收集为0的对象。<br>致命问题是无法解决循环引用的问题。</p>
<h3 id="复制（copying）"><a href="#复制（copying）" class="headerlink" title="复制（copying）"></a>复制（copying）</h3><p>eg：survivor from to<br>此算法将内存空间分为两份。每次使用其中一个区域。（占用空间）<br>垃圾回收时，遍历当前使用的区域，把正在使用中的对象复制到另一个区域中。</p>
<h3 id="标记清楚（Mark-Sweep）"><a href="#标记清楚（Mark-Sweep）" class="headerlink" title="标记清楚（Mark-Sweep）"></a>标记清楚（Mark-Sweep）</h3><p>执行分为两阶段。<br>第一阶段：从对象根节点开始标记所有被引用的对象。<br>第二阶段：遍历整个堆，把未标记的对象清除，此算法需要暂停整个应用(Stop the world)。<br>同时会产生内存碎片。<br>缺点：<br>1）未使用的内存空间不连续，浪费。<br>2）暂停整个应用。</p>
<h3 id="标记整理（Mark-Compact）"><a href="#标记整理（Mark-Compact）" class="headerlink" title="标记整理（Mark-Compact）"></a>标记整理（Mark-Compact）</h3><p>执行分为两阶段。<br>第一阶段：从对象根节点开始标记所有被引用的对象。<br>第二阶段：遍历整个堆，把未标记的对象清除，同时把存活的对象压缩到一块，顺序排放，避免碎片问题。<br>避免了复制算法的空间问题。</p>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2018/09/13/JVM课程二/">JVM课程二</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="https://wxzhongwang.github.io/page/4/index.html">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2018-09-13T07:55:00.000Z" itemprop="datePublished">2018-09-13</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/JVM/">JVM</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h2 id="类加载器子系统和方法区："><a href="#类加载器子系统和方法区：" class="headerlink" title="类加载器子系统和方法区："></a>类加载器子系统和方法区：</h2><p>从文件系统中加载class文件，加载类信息。加载的信息存放于一个叫做方法区的内存空间。</p>
<blockquote>
<p>方法区中包括： 类信息，常量池（字符串字面量和数字常量）</p>
</blockquote>
<h2 id="堆："><a href="#堆：" class="headerlink" title="堆："></a>堆：</h2><p>主要内存空间。存放对象的实例。线程共享</p>
<h2 id="直接内存："><a href="#直接内存：" class="headerlink" title="直接内存："></a>直接内存：</h2><p>NIO允许Java程序直接访问直接内存。</p>
<p>不受JVM内存 -Xmx 最大堆大小限制。不属于堆内存。直接内存速率高于堆内存。</p>
<p>读写频繁的场合可能会用到直接内存，与系统内存挂钩。</p>
<h2 id="垃圾回收系统"><a href="#垃圾回收系统" class="headerlink" title="垃圾回收系统"></a>垃圾回收系统</h2><p>回收java堆，方法区，直接内存都可以回收。java所有的对象的释放都是隐式的。<br>垃圾回收系统后台默默运行，标示和释放对象，实现全自动化管理。</p>
<h2 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h2><p>每一个虚拟机线程都有一个私有的栈，栈在线程创建的时候被创建。栈保存着帧信息。</p>
<p>栈中保存方法中的局部变量，方法参数，和程序的调用，返回相关。</p>
<h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>本地方法栈和虚拟机栈类似，虚拟机栈用于方法的调用。本地方法栈则用于本地方法（Native API）的调用。</p>
<p>Java虚拟机的重要拓展之一，不同的操作系统本地方法的API也不一样。</p>
<h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p>线程私有，字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，<br>分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完。</p>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2018/09/12/JVM课程一/">JVM课程一</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="https://wxzhongwang.github.io/page/4/index.html">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2018-09-12T14:55:00.000Z" itemprop="datePublished">2018-09-12</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/JVM/">JVM</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <p>JDK 编译Java文件为Class文件<br>Class文件由JVM解释为Native Code</p>
<p>Java HotSpot:<br>热点代码，（类似于缓存）避免jvm频繁将class文件转换为cpu可以直接理解的代码（native code 本地代码）。</p>
<p>Client VM 是默认启用的版本，更适合C/S 在为客户端环境中启动减少启动时间而优化<br>Server VM 在内存分配上更大，更适合于B/S 在为服务端环境中最大化程序执行速度而优化</p>
<p>-client KNOWN<br>-server KNOWN</p>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2018/09/12/JVM课程三/">JVM课程三</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="https://wxzhongwang.github.io/page/4/index.html">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2018-09-12T14:55:00.000Z" itemprop="datePublished">2018-09-12</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/JVM/">JVM</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h1 id="JVM内存分代策略"><a href="#JVM内存分代策略" class="headerlink" title="JVM内存分代策略"></a>JVM内存分代策略</h1><p>堆内存一般分为几块：新生代，老年代和永久代。是垃圾回收最频繁的区域。</p>
<h2 id="分代的意义"><a href="#分代的意义" class="headerlink" title="分代的意义?"></a>分代的意义?</h2><p>给堆内存分代为了提高对象分配内存和垃圾回收的效率。    </p>
<p>如果堆内存没有划分区域，所有新创建的对象需要和生命周期很长的对象放在一起，（内存地址是连续的）。<br>随着程序的运行，堆内存需要频繁的进行垃圾收集，每次回收都需要遍历所有的对象，遍历花费的时间代价过大，<br>严重影响GC效率。</p>
<ul>
<li>新生代： 新创建的对象 频繁GC</li>
<li>老年代： 经过多次回收仍存活下来的对象 （GC频率低）</li>
<li>永久代： 静态属性、类信息等 （一般不回收）</li>
</ul>
<p>根据不同的区域（代），采用不同的垃圾回收算法。分代收集大大提升了收集效率。</p>
<blockquote>
<p>永久代是HotSpot中的概念。</p>
</blockquote>
<pre><code>    young             old         permanent
      |
Eden   From   To
伊甸园  |     |
           Survivor Spaces（幸存空间）

`
</code></pre>
        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2018/08/31/hello-world/">你好，世界</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="https://wxzhongwang.github.io/page/4/index.html">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2018-08-31T09:54:54.000Z" itemprop="datePublished">2018-08-31</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/前端/">前端</a>, <a class="article-tag-link" href="/tags/博客系统/">博客系统</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2018/08/16/ConcurrentHashMap线程安全/">ConcurrentHashMap线程安全的具体实现方式/底层具体实现</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="https://wxzhongwang.github.io/page/4/index.html">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2018-08-15T18:20:00.000Z" itemprop="datePublished">2018-08-16</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/Java容器/">Java容器</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h1 id="ConcurrentHashMap线程安全的具体实现方式-底层具体实现"><a href="#ConcurrentHashMap线程安全的具体实现方式-底层具体实现" class="headerlink" title="ConcurrentHashMap线程安全的具体实现方式/底层具体实现"></a>ConcurrentHashMap线程安全的具体实现方式/底层具体实现</h1><p><strong>JDK1.7的ConcurrentHashMap：</strong></p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/ConcurrentHashMap分段锁.jpg" alt="JDK1.7的ConcurrentHashMap"></p>
<p><strong>JDK1.8的ConcurrentHashMap（TreeBin: 红黑二叉树节点 Node: 链表节点）：</strong></p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/JDK1.8-ConcurrentHashMap-Structure.jpg" alt="JDK1.8的ConcurrentHashMap"></p>
<p>JDK1.7（上面有示意图）<br>首先将数据分为一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。</p>
<p>ConcurrentHashMap 是由 Segment 数组结构和 HashEntry 数组结构组成。</p>
<p>Segment 实现了 ReentrantLock,所以 Segment 是一种可重入锁，扮演锁的角色。HashEntry 用于存储键值对数据。</p>
<p>static class Segment&lt;K,V&gt; extends ReentrantLock implements Serializable {<br>}<br>一个 ConcurrentHashMap 里包含一个 Segment 数组。Segment 的结构和HashMap类似，是一种数组和链表结构，一个 Segment 包含一个 HashEntry 数组，每个 HashEntry 是一个链表结构的元素，每个 Segment 守护着一个HashEntry数组里的元素，当对 HashEntry 数组的数据进行修改时，必须首先获得对应的 Segment的锁。</p>
<p>JDK1.8 （上面有示意图）<br>ConcurrentHashMap取消了Segment分段锁，采用CAS和synchronized来保证并发安全。数据结构跟HashMap1.8的结构类似，数组+链表/红黑二叉树。Java 8在链表长度超过一定阈值（8）时将链表（寻址时间复杂度为O(N)）转换为红黑树（寻址时间复杂度为O(log(N))）</p>
<p>synchronized只锁定当前链表或红黑二叉树的首节点，这样只要hash不冲突，就不会产生并发，效率又提升N倍。</p>

        
    </section>
</article>




<nav class="page-nav">
    <a class="extend prev" rel="prev" href="/page/3/">&laquo; 上一页</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/15/">15</a><a class="extend next" rel="next" href="/page/5/">下一页 &raquo;</a>
</nav>


</div>
        <footer class="footer">
    Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, Theme by <a href="https://github.com/sanonz/hexo-theme-concise" target="_blank">Concise</a>

    
    <script>
        var _hmt = _hmt || [];
        (function () {
            var hm = document.createElement("script");
            hm.src = "https://hm.baidu.com/hm.js?e4027971a230b210f4671f485b33846a";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();
    </script>
    
</footer>

    </main>

    <script type="text/javascript" src="https://cdn.bootcss.com/jquery/1.9.0/jquery.min.js"></script>
    <script type="text/javascript">
    $(function() {
        var nodes = {
            nav: $('#nav'),
            aside: $('#aside'),
            asideInner: $('#aside-inner'),
            navInner: $('#nav-inner')
        };

        var doing = false;
        nodes.asideInner.on('webkitAnimationEnd mozAnimationEnd oAnimationEnd oanimationend animationend', function() {
            if (nodes.aside.hasClass('mobile-open')) {
                nodes.aside.removeClass('mobile-open');
            } else {
                nodes.aside.removeClass('mobile-close panel-show');
            }
            doing = false;
        });
        $('#open-panel, #aside-mask').on('click', function() {
            if (doing) {
                return;
            }
            
            if (nodes.aside.hasClass('panel-show')) {
                nodes.aside.addClass('mobile-close');
            } else {
                nodes.aside.addClass('mobile-open panel-show');
            }
        });
        $('#open-menus').on('click', function() {
            nodes.navInner.slideToggle();
        });

        if (window.innerWidth <= 960) {
            setTimeout(function() {
                nodes.navInner.slideUp();
            }, 3000);
        }
    });
    </script>
    

</body>
</html>
